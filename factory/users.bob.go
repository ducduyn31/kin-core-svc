// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"testing"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	models "github.com/danielng/kin-core-svc/models"
	"github.com/gofrs/uuid/v5"
	"github.com/jaswdr/faker/v2"
	"github.com/stephenafamo/bob"
)

type UserMod interface {
	Apply(context.Context, *UserTemplate)
}

type UserModFunc func(context.Context, *UserTemplate)

func (f UserModFunc) Apply(ctx context.Context, n *UserTemplate) {
	f(ctx, n)
}

type UserModSlice []UserMod

func (mods UserModSlice) Apply(ctx context.Context, n *UserTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// UserTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type UserTemplate struct {
	ID          func() uuid.UUID
	Auth0Sub    func() string
	DisplayName func() string
	Avatar      func() null.Val[string]
	Bio         func() null.Val[string]
	PhoneNumber func() null.Val[string]
	Timezone    func() string
	CreatedAt   func() time.Time
	UpdatedAt   func() time.Time

	r userR
	f *Factory

	alreadyPersisted bool
}

type userR struct {
	AvailabilityAutoRules    []*userRAvailabilityAutoRulesR
	AvailabilityWindows      []*userRAvailabilityWindowsR
	CheckIns                 []*userRCheckInsR
	InviteeCircleInvitations []*userRInviteeCircleInvitationsR
	InviterCircleInvitations []*userRInviterCircleInvitationsR
	CircleMembers            []*userRCircleMembersR
	CircleSharingPreferences []*userRCircleSharingPreferencesR
	CreatedByCircles         []*userRCreatedByCirclesR
	FromUserContactRequests  []*userRFromUserContactRequestsR
	ToUserContactRequests    []*userRToUserContactRequestsR
	ContactContacts          []*userRContactContactsR
	Contacts                 []*userRContactsR
	ConversationParticipants []*userRConversationParticipantsR
	LocationHistories        []*userRLocationHistoriesR
	Media                    []*userRMediaR
	MessageDeletions         []*userRMessageDeletionsR
	MessageReactions         []*userRMessageReactionsR
	MessageReceipts          []*userRMessageReceiptsR
	SenderMessages           []*userRSenderMessagesR
	Places                   []*userRPlacesR
	UserAvailability         *userRUserAvailabilityR
	UserLocation             *userRUserLocationR
	UserPreference           *userRUserPreferenceR
}

type userRAvailabilityAutoRulesR struct {
	number int
	o      *AvailabilityAutoRuleTemplate
}
type userRAvailabilityWindowsR struct {
	number int
	o      *AvailabilityWindowTemplate
}
type userRCheckInsR struct {
	number int
	o      *CheckInTemplate
}
type userRInviteeCircleInvitationsR struct {
	number int
	o      *CircleInvitationTemplate
}
type userRInviterCircleInvitationsR struct {
	number int
	o      *CircleInvitationTemplate
}
type userRCircleMembersR struct {
	number int
	o      *CircleMemberTemplate
}
type userRCircleSharingPreferencesR struct {
	number int
	o      *CircleSharingPreferenceTemplate
}
type userRCreatedByCirclesR struct {
	number int
	o      *CircleTemplate
}
type userRFromUserContactRequestsR struct {
	number int
	o      *ContactRequestTemplate
}
type userRToUserContactRequestsR struct {
	number int
	o      *ContactRequestTemplate
}
type userRContactContactsR struct {
	number int
	o      *ContactTemplate
}
type userRContactsR struct {
	number int
	o      *ContactTemplate
}
type userRConversationParticipantsR struct {
	number int
	o      *ConversationParticipantTemplate
}
type userRLocationHistoriesR struct {
	number int
	o      *LocationHistoryTemplate
}
type userRMediaR struct {
	number int
	o      *MediumTemplate
}
type userRMessageDeletionsR struct {
	number int
	o      *MessageDeletionTemplate
}
type userRMessageReactionsR struct {
	number int
	o      *MessageReactionTemplate
}
type userRMessageReceiptsR struct {
	number int
	o      *MessageReceiptTemplate
}
type userRSenderMessagesR struct {
	number int
	o      *MessageTemplate
}
type userRPlacesR struct {
	number int
	o      *PlaceTemplate
}
type userRUserAvailabilityR struct {
	o *UserAvailabilityTemplate
}
type userRUserLocationR struct {
	o *UserLocationTemplate
}
type userRUserPreferenceR struct {
	o *UserPreferenceTemplate
}

// Apply mods to the UserTemplate
func (o *UserTemplate) Apply(ctx context.Context, mods ...UserMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.User
// according to the relationships in the template. Nothing is inserted into the db
func (t UserTemplate) setModelRels(o *models.User) {
	if t.r.AvailabilityAutoRules != nil {
		rel := models.AvailabilityAutoRuleSlice{}
		for _, r := range t.r.AvailabilityAutoRules {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.AvailabilityAutoRules = rel
	}

	if t.r.AvailabilityWindows != nil {
		rel := models.AvailabilityWindowSlice{}
		for _, r := range t.r.AvailabilityWindows {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.AvailabilityWindows = rel
	}

	if t.r.CheckIns != nil {
		rel := models.CheckInSlice{}
		for _, r := range t.r.CheckIns {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.CheckIns = rel
	}

	if t.r.InviteeCircleInvitations != nil {
		rel := models.CircleInvitationSlice{}
		for _, r := range t.r.InviteeCircleInvitations {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.InviteeID = null.From(o.ID) // h2
				rel.R.InviteeUser = o
			}
			rel = append(rel, related...)
		}
		o.R.InviteeCircleInvitations = rel
	}

	if t.r.InviterCircleInvitations != nil {
		rel := models.CircleInvitationSlice{}
		for _, r := range t.r.InviterCircleInvitations {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.InviterID = o.ID // h2
				rel.R.InviterUser = o
			}
			rel = append(rel, related...)
		}
		o.R.InviterCircleInvitations = rel
	}

	if t.r.CircleMembers != nil {
		rel := models.CircleMemberSlice{}
		for _, r := range t.r.CircleMembers {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.CircleMembers = rel
	}

	if t.r.CircleSharingPreferences != nil {
		rel := models.CircleSharingPreferenceSlice{}
		for _, r := range t.r.CircleSharingPreferences {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.CircleSharingPreferences = rel
	}

	if t.r.CreatedByCircles != nil {
		rel := models.CircleSlice{}
		for _, r := range t.r.CreatedByCircles {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.CreatedBy = o.ID // h2
				rel.R.CreatedByUser = o
			}
			rel = append(rel, related...)
		}
		o.R.CreatedByCircles = rel
	}

	if t.r.FromUserContactRequests != nil {
		rel := models.ContactRequestSlice{}
		for _, r := range t.r.FromUserContactRequests {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.FromUserID = o.ID // h2
				rel.R.FromUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.FromUserContactRequests = rel
	}

	if t.r.ToUserContactRequests != nil {
		rel := models.ContactRequestSlice{}
		for _, r := range t.r.ToUserContactRequests {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.ToUserID = o.ID // h2
				rel.R.ToUserUser = o
			}
			rel = append(rel, related...)
		}
		o.R.ToUserContactRequests = rel
	}

	if t.r.ContactContacts != nil {
		rel := models.ContactSlice{}
		for _, r := range t.r.ContactContacts {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.ContactID = o.ID // h2
				rel.R.ContactUser = o
			}
			rel = append(rel, related...)
		}
		o.R.ContactContacts = rel
	}

	if t.r.Contacts != nil {
		rel := models.ContactSlice{}
		for _, r := range t.r.Contacts {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.Contacts = rel
	}

	if t.r.ConversationParticipants != nil {
		rel := models.ConversationParticipantSlice{}
		for _, r := range t.r.ConversationParticipants {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.ConversationParticipants = rel
	}

	if t.r.LocationHistories != nil {
		rel := models.LocationHistorySlice{}
		for _, r := range t.r.LocationHistories {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.LocationHistories = rel
	}

	if t.r.Media != nil {
		rel := models.MediumSlice{}
		for _, r := range t.r.Media {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.Media = rel
	}

	if t.r.MessageDeletions != nil {
		rel := models.MessageDeletionSlice{}
		for _, r := range t.r.MessageDeletions {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.MessageDeletions = rel
	}

	if t.r.MessageReactions != nil {
		rel := models.MessageReactionSlice{}
		for _, r := range t.r.MessageReactions {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.MessageReactions = rel
	}

	if t.r.MessageReceipts != nil {
		rel := models.MessageReceiptSlice{}
		for _, r := range t.r.MessageReceipts {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.MessageReceipts = rel
	}

	if t.r.SenderMessages != nil {
		rel := models.MessageSlice{}
		for _, r := range t.r.SenderMessages {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.SenderID = o.ID // h2
				rel.R.SenderUser = o
			}
			rel = append(rel, related...)
		}
		o.R.SenderMessages = rel
	}

	if t.r.Places != nil {
		rel := models.PlaceSlice{}
		for _, r := range t.r.Places {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.UserID = o.ID // h2
				rel.R.User = o
			}
			rel = append(rel, related...)
		}
		o.R.Places = rel
	}

	if t.r.UserAvailability != nil {
		rel := t.r.UserAvailability.o.Build()
		rel.R.User = o
		rel.UserID = o.ID // h2
		o.R.UserAvailability = rel
	}

	if t.r.UserLocation != nil {
		rel := t.r.UserLocation.o.Build()
		rel.R.User = o
		rel.UserID = o.ID // h2
		o.R.UserLocation = rel
	}

	if t.r.UserPreference != nil {
		rel := t.r.UserPreference.o.Build()
		rel.R.User = o
		rel.UserID = o.ID // h2
		o.R.UserPreference = rel
	}
}

// BuildSetter returns an *models.UserSetter
// this does nothing with the relationship templates
func (o UserTemplate) BuildSetter() *models.UserSetter {
	m := &models.UserSetter{}

	if o.ID != nil {
		val := o.ID()
		m.ID = omit.From(val)
	}
	if o.Auth0Sub != nil {
		val := o.Auth0Sub()
		m.Auth0Sub = omit.From(val)
	}
	if o.DisplayName != nil {
		val := o.DisplayName()
		m.DisplayName = omit.From(val)
	}
	if o.Avatar != nil {
		val := o.Avatar()
		m.Avatar = omitnull.FromNull(val)
	}
	if o.Bio != nil {
		val := o.Bio()
		m.Bio = omitnull.FromNull(val)
	}
	if o.PhoneNumber != nil {
		val := o.PhoneNumber()
		m.PhoneNumber = omitnull.FromNull(val)
	}
	if o.Timezone != nil {
		val := o.Timezone()
		m.Timezone = omit.From(val)
	}
	if o.CreatedAt != nil {
		val := o.CreatedAt()
		m.CreatedAt = omit.From(val)
	}
	if o.UpdatedAt != nil {
		val := o.UpdatedAt()
		m.UpdatedAt = omit.From(val)
	}

	return m
}

// BuildManySetter returns an []*models.UserSetter
// this does nothing with the relationship templates
func (o UserTemplate) BuildManySetter(number int) []*models.UserSetter {
	m := make([]*models.UserSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.User
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserTemplate.Create
func (o UserTemplate) Build() *models.User {
	m := &models.User{}

	if o.ID != nil {
		m.ID = o.ID()
	}
	if o.Auth0Sub != nil {
		m.Auth0Sub = o.Auth0Sub()
	}
	if o.DisplayName != nil {
		m.DisplayName = o.DisplayName()
	}
	if o.Avatar != nil {
		m.Avatar = o.Avatar()
	}
	if o.Bio != nil {
		m.Bio = o.Bio()
	}
	if o.PhoneNumber != nil {
		m.PhoneNumber = o.PhoneNumber()
	}
	if o.Timezone != nil {
		m.Timezone = o.Timezone()
	}
	if o.CreatedAt != nil {
		m.CreatedAt = o.CreatedAt()
	}
	if o.UpdatedAt != nil {
		m.UpdatedAt = o.UpdatedAt()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.UserSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use UserTemplate.CreateMany
func (o UserTemplate) BuildMany(number int) models.UserSlice {
	m := make(models.UserSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableUser(m *models.UserSetter) {
	if !(m.ID.IsValue()) {
		val := random_uuid_UUID(nil)
		m.ID = omit.From(val)
	}
	if !(m.Auth0Sub.IsValue()) {
		val := random_string(nil, "255")
		m.Auth0Sub = omit.From(val)
	}
	if !(m.DisplayName.IsValue()) {
		val := random_string(nil, "100")
		m.DisplayName = omit.From(val)
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.User
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *UserTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.User) error {
	var err error

	isAvailabilityAutoRulesDone, _ := userRelAvailabilityAutoRulesCtx.Value(ctx)
	if !isAvailabilityAutoRulesDone && o.r.AvailabilityAutoRules != nil {
		ctx = userRelAvailabilityAutoRulesCtx.WithValue(ctx, true)
		for _, r := range o.r.AvailabilityAutoRules {
			if r.o.alreadyPersisted {
				m.R.AvailabilityAutoRules = append(m.R.AvailabilityAutoRules, r.o.Build())
			} else {
				rel0, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachAvailabilityAutoRules(ctx, exec, rel0...)
				if err != nil {
					return err
				}
			}
		}
	}

	isAvailabilityWindowsDone, _ := userRelAvailabilityWindowsCtx.Value(ctx)
	if !isAvailabilityWindowsDone && o.r.AvailabilityWindows != nil {
		ctx = userRelAvailabilityWindowsCtx.WithValue(ctx, true)
		for _, r := range o.r.AvailabilityWindows {
			if r.o.alreadyPersisted {
				m.R.AvailabilityWindows = append(m.R.AvailabilityWindows, r.o.Build())
			} else {
				rel1, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachAvailabilityWindows(ctx, exec, rel1...)
				if err != nil {
					return err
				}
			}
		}
	}

	isCheckInsDone, _ := userRelCheckInsCtx.Value(ctx)
	if !isCheckInsDone && o.r.CheckIns != nil {
		ctx = userRelCheckInsCtx.WithValue(ctx, true)
		for _, r := range o.r.CheckIns {
			if r.o.alreadyPersisted {
				m.R.CheckIns = append(m.R.CheckIns, r.o.Build())
			} else {
				rel2, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachCheckIns(ctx, exec, rel2...)
				if err != nil {
					return err
				}
			}
		}
	}

	isInviteeCircleInvitationsDone, _ := userRelInviteeCircleInvitationsCtx.Value(ctx)
	if !isInviteeCircleInvitationsDone && o.r.InviteeCircleInvitations != nil {
		ctx = userRelInviteeCircleInvitationsCtx.WithValue(ctx, true)
		for _, r := range o.r.InviteeCircleInvitations {
			if r.o.alreadyPersisted {
				m.R.InviteeCircleInvitations = append(m.R.InviteeCircleInvitations, r.o.Build())
			} else {
				rel3, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachInviteeCircleInvitations(ctx, exec, rel3...)
				if err != nil {
					return err
				}
			}
		}
	}

	isInviterCircleInvitationsDone, _ := userRelInviterCircleInvitationsCtx.Value(ctx)
	if !isInviterCircleInvitationsDone && o.r.InviterCircleInvitations != nil {
		ctx = userRelInviterCircleInvitationsCtx.WithValue(ctx, true)
		for _, r := range o.r.InviterCircleInvitations {
			if r.o.alreadyPersisted {
				m.R.InviterCircleInvitations = append(m.R.InviterCircleInvitations, r.o.Build())
			} else {
				rel4, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachInviterCircleInvitations(ctx, exec, rel4...)
				if err != nil {
					return err
				}
			}
		}
	}

	isCircleMembersDone, _ := userRelCircleMembersCtx.Value(ctx)
	if !isCircleMembersDone && o.r.CircleMembers != nil {
		ctx = userRelCircleMembersCtx.WithValue(ctx, true)
		for _, r := range o.r.CircleMembers {
			if r.o.alreadyPersisted {
				m.R.CircleMembers = append(m.R.CircleMembers, r.o.Build())
			} else {
				rel5, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachCircleMembers(ctx, exec, rel5...)
				if err != nil {
					return err
				}
			}
		}
	}

	isCircleSharingPreferencesDone, _ := userRelCircleSharingPreferencesCtx.Value(ctx)
	if !isCircleSharingPreferencesDone && o.r.CircleSharingPreferences != nil {
		ctx = userRelCircleSharingPreferencesCtx.WithValue(ctx, true)
		for _, r := range o.r.CircleSharingPreferences {
			if r.o.alreadyPersisted {
				m.R.CircleSharingPreferences = append(m.R.CircleSharingPreferences, r.o.Build())
			} else {
				rel6, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachCircleSharingPreferences(ctx, exec, rel6...)
				if err != nil {
					return err
				}
			}
		}
	}

	isCreatedByCirclesDone, _ := userRelCreatedByCirclesCtx.Value(ctx)
	if !isCreatedByCirclesDone && o.r.CreatedByCircles != nil {
		ctx = userRelCreatedByCirclesCtx.WithValue(ctx, true)
		for _, r := range o.r.CreatedByCircles {
			if r.o.alreadyPersisted {
				m.R.CreatedByCircles = append(m.R.CreatedByCircles, r.o.Build())
			} else {
				rel7, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachCreatedByCircles(ctx, exec, rel7...)
				if err != nil {
					return err
				}
			}
		}
	}

	isFromUserContactRequestsDone, _ := userRelFromUserContactRequestsCtx.Value(ctx)
	if !isFromUserContactRequestsDone && o.r.FromUserContactRequests != nil {
		ctx = userRelFromUserContactRequestsCtx.WithValue(ctx, true)
		for _, r := range o.r.FromUserContactRequests {
			if r.o.alreadyPersisted {
				m.R.FromUserContactRequests = append(m.R.FromUserContactRequests, r.o.Build())
			} else {
				rel8, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachFromUserContactRequests(ctx, exec, rel8...)
				if err != nil {
					return err
				}
			}
		}
	}

	isToUserContactRequestsDone, _ := userRelToUserContactRequestsCtx.Value(ctx)
	if !isToUserContactRequestsDone && o.r.ToUserContactRequests != nil {
		ctx = userRelToUserContactRequestsCtx.WithValue(ctx, true)
		for _, r := range o.r.ToUserContactRequests {
			if r.o.alreadyPersisted {
				m.R.ToUserContactRequests = append(m.R.ToUserContactRequests, r.o.Build())
			} else {
				rel9, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachToUserContactRequests(ctx, exec, rel9...)
				if err != nil {
					return err
				}
			}
		}
	}

	isContactContactsDone, _ := userRelContactContactsCtx.Value(ctx)
	if !isContactContactsDone && o.r.ContactContacts != nil {
		ctx = userRelContactContactsCtx.WithValue(ctx, true)
		for _, r := range o.r.ContactContacts {
			if r.o.alreadyPersisted {
				m.R.ContactContacts = append(m.R.ContactContacts, r.o.Build())
			} else {
				rel10, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachContactContacts(ctx, exec, rel10...)
				if err != nil {
					return err
				}
			}
		}
	}

	isContactsDone, _ := userRelContactsCtx.Value(ctx)
	if !isContactsDone && o.r.Contacts != nil {
		ctx = userRelContactsCtx.WithValue(ctx, true)
		for _, r := range o.r.Contacts {
			if r.o.alreadyPersisted {
				m.R.Contacts = append(m.R.Contacts, r.o.Build())
			} else {
				rel11, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachContacts(ctx, exec, rel11...)
				if err != nil {
					return err
				}
			}
		}
	}

	isConversationParticipantsDone, _ := userRelConversationParticipantsCtx.Value(ctx)
	if !isConversationParticipantsDone && o.r.ConversationParticipants != nil {
		ctx = userRelConversationParticipantsCtx.WithValue(ctx, true)
		for _, r := range o.r.ConversationParticipants {
			if r.o.alreadyPersisted {
				m.R.ConversationParticipants = append(m.R.ConversationParticipants, r.o.Build())
			} else {
				rel12, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachConversationParticipants(ctx, exec, rel12...)
				if err != nil {
					return err
				}
			}
		}
	}

	isLocationHistoriesDone, _ := userRelLocationHistoriesCtx.Value(ctx)
	if !isLocationHistoriesDone && o.r.LocationHistories != nil {
		ctx = userRelLocationHistoriesCtx.WithValue(ctx, true)
		for _, r := range o.r.LocationHistories {
			if r.o.alreadyPersisted {
				m.R.LocationHistories = append(m.R.LocationHistories, r.o.Build())
			} else {
				rel13, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachLocationHistories(ctx, exec, rel13...)
				if err != nil {
					return err
				}
			}
		}
	}

	isMediaDone, _ := userRelMediaCtx.Value(ctx)
	if !isMediaDone && o.r.Media != nil {
		ctx = userRelMediaCtx.WithValue(ctx, true)
		for _, r := range o.r.Media {
			if r.o.alreadyPersisted {
				m.R.Media = append(m.R.Media, r.o.Build())
			} else {
				rel14, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachMedia(ctx, exec, rel14...)
				if err != nil {
					return err
				}
			}
		}
	}

	isMessageDeletionsDone, _ := userRelMessageDeletionsCtx.Value(ctx)
	if !isMessageDeletionsDone && o.r.MessageDeletions != nil {
		ctx = userRelMessageDeletionsCtx.WithValue(ctx, true)
		for _, r := range o.r.MessageDeletions {
			if r.o.alreadyPersisted {
				m.R.MessageDeletions = append(m.R.MessageDeletions, r.o.Build())
			} else {
				rel15, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachMessageDeletions(ctx, exec, rel15...)
				if err != nil {
					return err
				}
			}
		}
	}

	isMessageReactionsDone, _ := userRelMessageReactionsCtx.Value(ctx)
	if !isMessageReactionsDone && o.r.MessageReactions != nil {
		ctx = userRelMessageReactionsCtx.WithValue(ctx, true)
		for _, r := range o.r.MessageReactions {
			if r.o.alreadyPersisted {
				m.R.MessageReactions = append(m.R.MessageReactions, r.o.Build())
			} else {
				rel16, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachMessageReactions(ctx, exec, rel16...)
				if err != nil {
					return err
				}
			}
		}
	}

	isMessageReceiptsDone, _ := userRelMessageReceiptsCtx.Value(ctx)
	if !isMessageReceiptsDone && o.r.MessageReceipts != nil {
		ctx = userRelMessageReceiptsCtx.WithValue(ctx, true)
		for _, r := range o.r.MessageReceipts {
			if r.o.alreadyPersisted {
				m.R.MessageReceipts = append(m.R.MessageReceipts, r.o.Build())
			} else {
				rel17, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachMessageReceipts(ctx, exec, rel17...)
				if err != nil {
					return err
				}
			}
		}
	}

	isSenderMessagesDone, _ := userRelSenderMessagesCtx.Value(ctx)
	if !isSenderMessagesDone && o.r.SenderMessages != nil {
		ctx = userRelSenderMessagesCtx.WithValue(ctx, true)
		for _, r := range o.r.SenderMessages {
			if r.o.alreadyPersisted {
				m.R.SenderMessages = append(m.R.SenderMessages, r.o.Build())
			} else {
				rel18, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachSenderMessages(ctx, exec, rel18...)
				if err != nil {
					return err
				}
			}
		}
	}

	isPlacesDone, _ := userRelPlacesCtx.Value(ctx)
	if !isPlacesDone && o.r.Places != nil {
		ctx = userRelPlacesCtx.WithValue(ctx, true)
		for _, r := range o.r.Places {
			if r.o.alreadyPersisted {
				m.R.Places = append(m.R.Places, r.o.Build())
			} else {
				rel19, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachPlaces(ctx, exec, rel19...)
				if err != nil {
					return err
				}
			}
		}
	}

	isUserAvailabilityDone, _ := userRelUserAvailabilityCtx.Value(ctx)
	if !isUserAvailabilityDone && o.r.UserAvailability != nil {
		ctx = userRelUserAvailabilityCtx.WithValue(ctx, true)
		if o.r.UserAvailability.o.alreadyPersisted {
			m.R.UserAvailability = o.r.UserAvailability.o.Build()
		} else {
			var rel20 *models.UserAvailability
			rel20, err = o.r.UserAvailability.o.Create(ctx, exec)
			if err != nil {
				return err
			}
			err = m.AttachUserAvailability(ctx, exec, rel20)
			if err != nil {
				return err
			}
		}

	}

	isUserLocationDone, _ := userRelUserLocationCtx.Value(ctx)
	if !isUserLocationDone && o.r.UserLocation != nil {
		ctx = userRelUserLocationCtx.WithValue(ctx, true)
		if o.r.UserLocation.o.alreadyPersisted {
			m.R.UserLocation = o.r.UserLocation.o.Build()
		} else {
			var rel21 *models.UserLocation
			rel21, err = o.r.UserLocation.o.Create(ctx, exec)
			if err != nil {
				return err
			}
			err = m.AttachUserLocation(ctx, exec, rel21)
			if err != nil {
				return err
			}
		}

	}

	isUserPreferenceDone, _ := userRelUserPreferenceCtx.Value(ctx)
	if !isUserPreferenceDone && o.r.UserPreference != nil {
		ctx = userRelUserPreferenceCtx.WithValue(ctx, true)
		if o.r.UserPreference.o.alreadyPersisted {
			m.R.UserPreference = o.r.UserPreference.o.Build()
		} else {
			var rel22 *models.UserPreference
			rel22, err = o.r.UserPreference.o.Create(ctx, exec)
			if err != nil {
				return err
			}
			err = m.AttachUserPreference(ctx, exec, rel22)
			if err != nil {
				return err
			}
		}

	}

	return err
}

// Create builds a user and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *UserTemplate) Create(ctx context.Context, exec bob.Executor) (*models.User, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableUser(opt)

	m, err := models.Users.Insert(opt).One(ctx, exec)
	if err != nil {
		return nil, err
	}

	if err := o.insertOptRels(ctx, exec, m); err != nil {
		return nil, err
	}
	return m, err
}

// MustCreate builds a user and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *UserTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.User {
	m, err := o.Create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a user and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *UserTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.User {
	tb.Helper()
	m, err := o.Create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// CreateMany builds multiple users and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o UserTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.UserSlice, error) {
	var err error
	m := make(models.UserSlice, number)

	for i := range m {
		m[i], err = o.Create(ctx, exec)
		if err != nil {
			return nil, err
		}
	}

	return m, nil
}

// MustCreateMany builds multiple users and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o UserTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.UserSlice {
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple users and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o UserTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.UserSlice {
	tb.Helper()
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// User has methods that act as mods for the UserTemplate
var UserMods userMods

type userMods struct{}

func (m userMods) RandomizeAllColumns(f *faker.Faker) UserMod {
	return UserModSlice{
		UserMods.RandomID(f),
		UserMods.RandomAuth0Sub(f),
		UserMods.RandomDisplayName(f),
		UserMods.RandomAvatar(f),
		UserMods.RandomBio(f),
		UserMods.RandomPhoneNumber(f),
		UserMods.RandomTimezone(f),
		UserMods.RandomCreatedAt(f),
		UserMods.RandomUpdatedAt(f),
	}
}

// Set the model columns to this value
func (m userMods) ID(val uuid.UUID) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m userMods) IDFunc(f func() uuid.UUID) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ID = f
	})
}

// Clear any values for the column
func (m userMods) UnsetID() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomID(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.ID = func() uuid.UUID {
			return random_uuid_UUID(f)
		}
	})
}

// Set the model columns to this value
func (m userMods) Auth0Sub(val string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Auth0Sub = func() string { return val }
	})
}

// Set the Column from the function
func (m userMods) Auth0SubFunc(f func() string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Auth0Sub = f
	})
}

// Clear any values for the column
func (m userMods) UnsetAuth0Sub() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Auth0Sub = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomAuth0Sub(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Auth0Sub = func() string {
			return random_string(f, "255")
		}
	})
}

// Set the model columns to this value
func (m userMods) DisplayName(val string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.DisplayName = func() string { return val }
	})
}

// Set the Column from the function
func (m userMods) DisplayNameFunc(f func() string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.DisplayName = f
	})
}

// Clear any values for the column
func (m userMods) UnsetDisplayName() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.DisplayName = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomDisplayName(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.DisplayName = func() string {
			return random_string(f, "100")
		}
	})
}

// Set the model columns to this value
func (m userMods) Avatar(val null.Val[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Avatar = func() null.Val[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) AvatarFunc(f func() null.Val[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Avatar = f
	})
}

// Clear any values for the column
func (m userMods) UnsetAvatar() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Avatar = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomAvatar(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Avatar = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomAvatarNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Avatar = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m userMods) Bio(val null.Val[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Bio = func() null.Val[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) BioFunc(f func() null.Val[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Bio = f
	})
}

// Clear any values for the column
func (m userMods) UnsetBio() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Bio = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomBio(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Bio = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "500")
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomBioNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Bio = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "500")
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m userMods) PhoneNumber(val null.Val[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PhoneNumber = func() null.Val[string] { return val }
	})
}

// Set the Column from the function
func (m userMods) PhoneNumberFunc(f func() null.Val[string]) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PhoneNumber = f
	})
}

// Clear any values for the column
func (m userMods) UnsetPhoneNumber() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PhoneNumber = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m userMods) RandomPhoneNumber(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PhoneNumber = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "20")
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m userMods) RandomPhoneNumberNotNull(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.PhoneNumber = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f, "20")
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m userMods) Timezone(val string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Timezone = func() string { return val }
	})
}

// Set the Column from the function
func (m userMods) TimezoneFunc(f func() string) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Timezone = f
	})
}

// Clear any values for the column
func (m userMods) UnsetTimezone() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Timezone = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomTimezone(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.Timezone = func() string {
			return random_string(f, "50")
		}
	})
}

// Set the model columns to this value
func (m userMods) CreatedAt(val time.Time) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = func() time.Time { return val }
	})
}

// Set the Column from the function
func (m userMods) CreatedAtFunc(f func() time.Time) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = f
	})
}

// Clear any values for the column
func (m userMods) UnsetCreatedAt() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomCreatedAt(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.CreatedAt = func() time.Time {
			return random_time_Time(f)
		}
	})
}

// Set the model columns to this value
func (m userMods) UpdatedAt(val time.Time) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = func() time.Time { return val }
	})
}

// Set the Column from the function
func (m userMods) UpdatedAtFunc(f func() time.Time) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = f
	})
}

// Clear any values for the column
func (m userMods) UnsetUpdatedAt() UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m userMods) RandomUpdatedAt(f *faker.Faker) UserMod {
	return UserModFunc(func(_ context.Context, o *UserTemplate) {
		o.UpdatedAt = func() time.Time {
			return random_time_Time(f)
		}
	})
}

func (m userMods) WithParentsCascading() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		if isDone, _ := userWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = userWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewUserAvailabilityWithContext(ctx, UserAvailabilityMods.WithParentsCascading())
			m.WithUserAvailability(related).Apply(ctx, o)
		}
		{

			related := o.f.NewUserLocationWithContext(ctx, UserLocationMods.WithParentsCascading())
			m.WithUserLocation(related).Apply(ctx, o)
		}
		{

			related := o.f.NewUserPreferenceWithContext(ctx, UserPreferenceMods.WithParentsCascading())
			m.WithUserPreference(related).Apply(ctx, o)
		}
	})
}

func (m userMods) WithUserAvailability(rel *UserAvailabilityTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserAvailability = &userRUserAvailabilityR{
			o: rel,
		}
	})
}

func (m userMods) WithNewUserAvailability(mods ...UserAvailabilityMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserAvailabilityWithContext(ctx, mods...)

		m.WithUserAvailability(related).Apply(ctx, o)
	})
}

func (m userMods) WithExistingUserAvailability(em *models.UserAvailability) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserAvailability = &userRUserAvailabilityR{
			o: o.f.FromExistingUserAvailability(em),
		}
	})
}

func (m userMods) WithoutUserAvailability() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserAvailability = nil
	})
}

func (m userMods) WithUserLocation(rel *UserLocationTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserLocation = &userRUserLocationR{
			o: rel,
		}
	})
}

func (m userMods) WithNewUserLocation(mods ...UserLocationMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserLocationWithContext(ctx, mods...)

		m.WithUserLocation(related).Apply(ctx, o)
	})
}

func (m userMods) WithExistingUserLocation(em *models.UserLocation) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserLocation = &userRUserLocationR{
			o: o.f.FromExistingUserLocation(em),
		}
	})
}

func (m userMods) WithoutUserLocation() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserLocation = nil
	})
}

func (m userMods) WithUserPreference(rel *UserPreferenceTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserPreference = &userRUserPreferenceR{
			o: rel,
		}
	})
}

func (m userMods) WithNewUserPreference(mods ...UserPreferenceMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewUserPreferenceWithContext(ctx, mods...)

		m.WithUserPreference(related).Apply(ctx, o)
	})
}

func (m userMods) WithExistingUserPreference(em *models.UserPreference) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserPreference = &userRUserPreferenceR{
			o: o.f.FromExistingUserPreference(em),
		}
	})
}

func (m userMods) WithoutUserPreference() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.UserPreference = nil
	})
}

func (m userMods) WithAvailabilityAutoRules(number int, related *AvailabilityAutoRuleTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AvailabilityAutoRules = []*userRAvailabilityAutoRulesR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewAvailabilityAutoRules(number int, mods ...AvailabilityAutoRuleMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewAvailabilityAutoRuleWithContext(ctx, mods...)
		m.WithAvailabilityAutoRules(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddAvailabilityAutoRules(number int, related *AvailabilityAutoRuleTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AvailabilityAutoRules = append(o.r.AvailabilityAutoRules, &userRAvailabilityAutoRulesR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewAvailabilityAutoRules(number int, mods ...AvailabilityAutoRuleMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewAvailabilityAutoRuleWithContext(ctx, mods...)
		m.AddAvailabilityAutoRules(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingAvailabilityAutoRules(existingModels ...*models.AvailabilityAutoRule) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.AvailabilityAutoRules = append(o.r.AvailabilityAutoRules, &userRAvailabilityAutoRulesR{
				o: o.f.FromExistingAvailabilityAutoRule(em),
			})
		}
	})
}

func (m userMods) WithoutAvailabilityAutoRules() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AvailabilityAutoRules = nil
	})
}

func (m userMods) WithAvailabilityWindows(number int, related *AvailabilityWindowTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AvailabilityWindows = []*userRAvailabilityWindowsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewAvailabilityWindows(number int, mods ...AvailabilityWindowMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewAvailabilityWindowWithContext(ctx, mods...)
		m.WithAvailabilityWindows(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddAvailabilityWindows(number int, related *AvailabilityWindowTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AvailabilityWindows = append(o.r.AvailabilityWindows, &userRAvailabilityWindowsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewAvailabilityWindows(number int, mods ...AvailabilityWindowMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewAvailabilityWindowWithContext(ctx, mods...)
		m.AddAvailabilityWindows(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingAvailabilityWindows(existingModels ...*models.AvailabilityWindow) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.AvailabilityWindows = append(o.r.AvailabilityWindows, &userRAvailabilityWindowsR{
				o: o.f.FromExistingAvailabilityWindow(em),
			})
		}
	})
}

func (m userMods) WithoutAvailabilityWindows() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.AvailabilityWindows = nil
	})
}

func (m userMods) WithCheckIns(number int, related *CheckInTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CheckIns = []*userRCheckInsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewCheckIns(number int, mods ...CheckInMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCheckInWithContext(ctx, mods...)
		m.WithCheckIns(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddCheckIns(number int, related *CheckInTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CheckIns = append(o.r.CheckIns, &userRCheckInsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewCheckIns(number int, mods ...CheckInMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCheckInWithContext(ctx, mods...)
		m.AddCheckIns(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingCheckIns(existingModels ...*models.CheckIn) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.CheckIns = append(o.r.CheckIns, &userRCheckInsR{
				o: o.f.FromExistingCheckIn(em),
			})
		}
	})
}

func (m userMods) WithoutCheckIns() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CheckIns = nil
	})
}

func (m userMods) WithInviteeCircleInvitations(number int, related *CircleInvitationTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.InviteeCircleInvitations = []*userRInviteeCircleInvitationsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewInviteeCircleInvitations(number int, mods ...CircleInvitationMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleInvitationWithContext(ctx, mods...)
		m.WithInviteeCircleInvitations(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddInviteeCircleInvitations(number int, related *CircleInvitationTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.InviteeCircleInvitations = append(o.r.InviteeCircleInvitations, &userRInviteeCircleInvitationsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewInviteeCircleInvitations(number int, mods ...CircleInvitationMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleInvitationWithContext(ctx, mods...)
		m.AddInviteeCircleInvitations(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingInviteeCircleInvitations(existingModels ...*models.CircleInvitation) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.InviteeCircleInvitations = append(o.r.InviteeCircleInvitations, &userRInviteeCircleInvitationsR{
				o: o.f.FromExistingCircleInvitation(em),
			})
		}
	})
}

func (m userMods) WithoutInviteeCircleInvitations() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.InviteeCircleInvitations = nil
	})
}

func (m userMods) WithInviterCircleInvitations(number int, related *CircleInvitationTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.InviterCircleInvitations = []*userRInviterCircleInvitationsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewInviterCircleInvitations(number int, mods ...CircleInvitationMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleInvitationWithContext(ctx, mods...)
		m.WithInviterCircleInvitations(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddInviterCircleInvitations(number int, related *CircleInvitationTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.InviterCircleInvitations = append(o.r.InviterCircleInvitations, &userRInviterCircleInvitationsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewInviterCircleInvitations(number int, mods ...CircleInvitationMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleInvitationWithContext(ctx, mods...)
		m.AddInviterCircleInvitations(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingInviterCircleInvitations(existingModels ...*models.CircleInvitation) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.InviterCircleInvitations = append(o.r.InviterCircleInvitations, &userRInviterCircleInvitationsR{
				o: o.f.FromExistingCircleInvitation(em),
			})
		}
	})
}

func (m userMods) WithoutInviterCircleInvitations() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.InviterCircleInvitations = nil
	})
}

func (m userMods) WithCircleMembers(number int, related *CircleMemberTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CircleMembers = []*userRCircleMembersR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewCircleMembers(number int, mods ...CircleMemberMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleMemberWithContext(ctx, mods...)
		m.WithCircleMembers(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddCircleMembers(number int, related *CircleMemberTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CircleMembers = append(o.r.CircleMembers, &userRCircleMembersR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewCircleMembers(number int, mods ...CircleMemberMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleMemberWithContext(ctx, mods...)
		m.AddCircleMembers(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingCircleMembers(existingModels ...*models.CircleMember) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.CircleMembers = append(o.r.CircleMembers, &userRCircleMembersR{
				o: o.f.FromExistingCircleMember(em),
			})
		}
	})
}

func (m userMods) WithoutCircleMembers() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CircleMembers = nil
	})
}

func (m userMods) WithCircleSharingPreferences(number int, related *CircleSharingPreferenceTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CircleSharingPreferences = []*userRCircleSharingPreferencesR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewCircleSharingPreferences(number int, mods ...CircleSharingPreferenceMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleSharingPreferenceWithContext(ctx, mods...)
		m.WithCircleSharingPreferences(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddCircleSharingPreferences(number int, related *CircleSharingPreferenceTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CircleSharingPreferences = append(o.r.CircleSharingPreferences, &userRCircleSharingPreferencesR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewCircleSharingPreferences(number int, mods ...CircleSharingPreferenceMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleSharingPreferenceWithContext(ctx, mods...)
		m.AddCircleSharingPreferences(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingCircleSharingPreferences(existingModels ...*models.CircleSharingPreference) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.CircleSharingPreferences = append(o.r.CircleSharingPreferences, &userRCircleSharingPreferencesR{
				o: o.f.FromExistingCircleSharingPreference(em),
			})
		}
	})
}

func (m userMods) WithoutCircleSharingPreferences() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CircleSharingPreferences = nil
	})
}

func (m userMods) WithCreatedByCircles(number int, related *CircleTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByCircles = []*userRCreatedByCirclesR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewCreatedByCircles(number int, mods ...CircleMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleWithContext(ctx, mods...)
		m.WithCreatedByCircles(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddCreatedByCircles(number int, related *CircleTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByCircles = append(o.r.CreatedByCircles, &userRCreatedByCirclesR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewCreatedByCircles(number int, mods ...CircleMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewCircleWithContext(ctx, mods...)
		m.AddCreatedByCircles(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingCreatedByCircles(existingModels ...*models.Circle) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.CreatedByCircles = append(o.r.CreatedByCircles, &userRCreatedByCirclesR{
				o: o.f.FromExistingCircle(em),
			})
		}
	})
}

func (m userMods) WithoutCreatedByCircles() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.CreatedByCircles = nil
	})
}

func (m userMods) WithFromUserContactRequests(number int, related *ContactRequestTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.FromUserContactRequests = []*userRFromUserContactRequestsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewFromUserContactRequests(number int, mods ...ContactRequestMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactRequestWithContext(ctx, mods...)
		m.WithFromUserContactRequests(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddFromUserContactRequests(number int, related *ContactRequestTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.FromUserContactRequests = append(o.r.FromUserContactRequests, &userRFromUserContactRequestsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewFromUserContactRequests(number int, mods ...ContactRequestMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactRequestWithContext(ctx, mods...)
		m.AddFromUserContactRequests(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingFromUserContactRequests(existingModels ...*models.ContactRequest) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.FromUserContactRequests = append(o.r.FromUserContactRequests, &userRFromUserContactRequestsR{
				o: o.f.FromExistingContactRequest(em),
			})
		}
	})
}

func (m userMods) WithoutFromUserContactRequests() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.FromUserContactRequests = nil
	})
}

func (m userMods) WithToUserContactRequests(number int, related *ContactRequestTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ToUserContactRequests = []*userRToUserContactRequestsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewToUserContactRequests(number int, mods ...ContactRequestMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactRequestWithContext(ctx, mods...)
		m.WithToUserContactRequests(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddToUserContactRequests(number int, related *ContactRequestTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ToUserContactRequests = append(o.r.ToUserContactRequests, &userRToUserContactRequestsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewToUserContactRequests(number int, mods ...ContactRequestMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactRequestWithContext(ctx, mods...)
		m.AddToUserContactRequests(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingToUserContactRequests(existingModels ...*models.ContactRequest) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.ToUserContactRequests = append(o.r.ToUserContactRequests, &userRToUserContactRequestsR{
				o: o.f.FromExistingContactRequest(em),
			})
		}
	})
}

func (m userMods) WithoutToUserContactRequests() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ToUserContactRequests = nil
	})
}

func (m userMods) WithContactContacts(number int, related *ContactTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ContactContacts = []*userRContactContactsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewContactContacts(number int, mods ...ContactMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactWithContext(ctx, mods...)
		m.WithContactContacts(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddContactContacts(number int, related *ContactTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ContactContacts = append(o.r.ContactContacts, &userRContactContactsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewContactContacts(number int, mods ...ContactMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactWithContext(ctx, mods...)
		m.AddContactContacts(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingContactContacts(existingModels ...*models.Contact) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.ContactContacts = append(o.r.ContactContacts, &userRContactContactsR{
				o: o.f.FromExistingContact(em),
			})
		}
	})
}

func (m userMods) WithoutContactContacts() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ContactContacts = nil
	})
}

func (m userMods) WithContacts(number int, related *ContactTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Contacts = []*userRContactsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewContacts(number int, mods ...ContactMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactWithContext(ctx, mods...)
		m.WithContacts(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddContacts(number int, related *ContactTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Contacts = append(o.r.Contacts, &userRContactsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewContacts(number int, mods ...ContactMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewContactWithContext(ctx, mods...)
		m.AddContacts(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingContacts(existingModels ...*models.Contact) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.Contacts = append(o.r.Contacts, &userRContactsR{
				o: o.f.FromExistingContact(em),
			})
		}
	})
}

func (m userMods) WithoutContacts() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Contacts = nil
	})
}

func (m userMods) WithConversationParticipants(number int, related *ConversationParticipantTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ConversationParticipants = []*userRConversationParticipantsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewConversationParticipants(number int, mods ...ConversationParticipantMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewConversationParticipantWithContext(ctx, mods...)
		m.WithConversationParticipants(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddConversationParticipants(number int, related *ConversationParticipantTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ConversationParticipants = append(o.r.ConversationParticipants, &userRConversationParticipantsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewConversationParticipants(number int, mods ...ConversationParticipantMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewConversationParticipantWithContext(ctx, mods...)
		m.AddConversationParticipants(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingConversationParticipants(existingModels ...*models.ConversationParticipant) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.ConversationParticipants = append(o.r.ConversationParticipants, &userRConversationParticipantsR{
				o: o.f.FromExistingConversationParticipant(em),
			})
		}
	})
}

func (m userMods) WithoutConversationParticipants() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.ConversationParticipants = nil
	})
}

func (m userMods) WithLocationHistories(number int, related *LocationHistoryTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.LocationHistories = []*userRLocationHistoriesR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewLocationHistories(number int, mods ...LocationHistoryMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewLocationHistoryWithContext(ctx, mods...)
		m.WithLocationHistories(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddLocationHistories(number int, related *LocationHistoryTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.LocationHistories = append(o.r.LocationHistories, &userRLocationHistoriesR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewLocationHistories(number int, mods ...LocationHistoryMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewLocationHistoryWithContext(ctx, mods...)
		m.AddLocationHistories(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingLocationHistories(existingModels ...*models.LocationHistory) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.LocationHistories = append(o.r.LocationHistories, &userRLocationHistoriesR{
				o: o.f.FromExistingLocationHistory(em),
			})
		}
	})
}

func (m userMods) WithoutLocationHistories() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.LocationHistories = nil
	})
}

func (m userMods) WithMedia(number int, related *MediumTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Media = []*userRMediaR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewMedia(number int, mods ...MediumMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMediumWithContext(ctx, mods...)
		m.WithMedia(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddMedia(number int, related *MediumTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Media = append(o.r.Media, &userRMediaR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewMedia(number int, mods ...MediumMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMediumWithContext(ctx, mods...)
		m.AddMedia(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingMedia(existingModels ...*models.Medium) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.Media = append(o.r.Media, &userRMediaR{
				o: o.f.FromExistingMedium(em),
			})
		}
	})
}

func (m userMods) WithoutMedia() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Media = nil
	})
}

func (m userMods) WithMessageDeletions(number int, related *MessageDeletionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageDeletions = []*userRMessageDeletionsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewMessageDeletions(number int, mods ...MessageDeletionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageDeletionWithContext(ctx, mods...)
		m.WithMessageDeletions(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddMessageDeletions(number int, related *MessageDeletionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageDeletions = append(o.r.MessageDeletions, &userRMessageDeletionsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewMessageDeletions(number int, mods ...MessageDeletionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageDeletionWithContext(ctx, mods...)
		m.AddMessageDeletions(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingMessageDeletions(existingModels ...*models.MessageDeletion) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.MessageDeletions = append(o.r.MessageDeletions, &userRMessageDeletionsR{
				o: o.f.FromExistingMessageDeletion(em),
			})
		}
	})
}

func (m userMods) WithoutMessageDeletions() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageDeletions = nil
	})
}

func (m userMods) WithMessageReactions(number int, related *MessageReactionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageReactions = []*userRMessageReactionsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewMessageReactions(number int, mods ...MessageReactionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageReactionWithContext(ctx, mods...)
		m.WithMessageReactions(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddMessageReactions(number int, related *MessageReactionTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageReactions = append(o.r.MessageReactions, &userRMessageReactionsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewMessageReactions(number int, mods ...MessageReactionMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageReactionWithContext(ctx, mods...)
		m.AddMessageReactions(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingMessageReactions(existingModels ...*models.MessageReaction) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.MessageReactions = append(o.r.MessageReactions, &userRMessageReactionsR{
				o: o.f.FromExistingMessageReaction(em),
			})
		}
	})
}

func (m userMods) WithoutMessageReactions() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageReactions = nil
	})
}

func (m userMods) WithMessageReceipts(number int, related *MessageReceiptTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageReceipts = []*userRMessageReceiptsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewMessageReceipts(number int, mods ...MessageReceiptMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageReceiptWithContext(ctx, mods...)
		m.WithMessageReceipts(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddMessageReceipts(number int, related *MessageReceiptTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageReceipts = append(o.r.MessageReceipts, &userRMessageReceiptsR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewMessageReceipts(number int, mods ...MessageReceiptMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageReceiptWithContext(ctx, mods...)
		m.AddMessageReceipts(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingMessageReceipts(existingModels ...*models.MessageReceipt) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.MessageReceipts = append(o.r.MessageReceipts, &userRMessageReceiptsR{
				o: o.f.FromExistingMessageReceipt(em),
			})
		}
	})
}

func (m userMods) WithoutMessageReceipts() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.MessageReceipts = nil
	})
}

func (m userMods) WithSenderMessages(number int, related *MessageTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.SenderMessages = []*userRSenderMessagesR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewSenderMessages(number int, mods ...MessageMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageWithContext(ctx, mods...)
		m.WithSenderMessages(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddSenderMessages(number int, related *MessageTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.SenderMessages = append(o.r.SenderMessages, &userRSenderMessagesR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewSenderMessages(number int, mods ...MessageMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewMessageWithContext(ctx, mods...)
		m.AddSenderMessages(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingSenderMessages(existingModels ...*models.Message) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.SenderMessages = append(o.r.SenderMessages, &userRSenderMessagesR{
				o: o.f.FromExistingMessage(em),
			})
		}
	})
}

func (m userMods) WithoutSenderMessages() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.SenderMessages = nil
	})
}

func (m userMods) WithPlaces(number int, related *PlaceTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Places = []*userRPlacesR{{
			number: number,
			o:      related,
		}}
	})
}

func (m userMods) WithNewPlaces(number int, mods ...PlaceMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewPlaceWithContext(ctx, mods...)
		m.WithPlaces(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddPlaces(number int, related *PlaceTemplate) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Places = append(o.r.Places, &userRPlacesR{
			number: number,
			o:      related,
		})
	})
}

func (m userMods) AddNewPlaces(number int, mods ...PlaceMod) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		related := o.f.NewPlaceWithContext(ctx, mods...)
		m.AddPlaces(number, related).Apply(ctx, o)
	})
}

func (m userMods) AddExistingPlaces(existingModels ...*models.Place) UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		for _, em := range existingModels {
			o.r.Places = append(o.r.Places, &userRPlacesR{
				o: o.f.FromExistingPlace(em),
			})
		}
	})
}

func (m userMods) WithoutPlaces() UserMod {
	return UserModFunc(func(ctx context.Context, o *UserTemplate) {
		o.r.Places = nil
	})
}
