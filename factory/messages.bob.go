// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	models "github.com/danielng/kin-core-svc/models"
	"github.com/gofrs/uuid/v5"
	"github.com/jaswdr/faker/v2"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/types"
)

type MessageMod interface {
	Apply(context.Context, *MessageTemplate)
}

type MessageModFunc func(context.Context, *MessageTemplate)

func (f MessageModFunc) Apply(ctx context.Context, n *MessageTemplate) {
	f(ctx, n)
}

type MessageModSlice []MessageMod

func (mods MessageModSlice) Apply(ctx context.Context, n *MessageTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// MessageTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type MessageTemplate struct {
	ID              func() uuid.UUID
	ConversationID  func() uuid.UUID
	SenderID        func() uuid.UUID
	ContentType     func() string
	ContentText     func() null.Val[string]
	ContentMediaID  func() null.Val[uuid.UUID]
	ContentMediaURL func() null.Val[string]
	ContentMetadata func() null.Val[types.JSON[json.RawMessage]]
	ReplyToID       func() null.Val[uuid.UUID]
	IsEdited        func() bool
	EditedAt        func() null.Val[time.Time]
	DeletedForAll   func() bool
	CreatedAt       func() time.Time

	r messageR
	f *Factory

	alreadyPersisted bool
}

type messageR struct {
	MessageDeletions []*messageRMessageDeletionsR
	MessageReactions []*messageRMessageReactionsR
	MessageReceipts  []*messageRMessageReceiptsR
	Conversation     *messageRConversationR
	SenderUser       *messageRSenderUserR
}

type messageRMessageDeletionsR struct {
	number int
	o      *MessageDeletionTemplate
}
type messageRMessageReactionsR struct {
	number int
	o      *MessageReactionTemplate
}
type messageRMessageReceiptsR struct {
	number int
	o      *MessageReceiptTemplate
}
type messageRConversationR struct {
	o *ConversationTemplate
}
type messageRSenderUserR struct {
	o *UserTemplate
}

// Apply mods to the MessageTemplate
func (o *MessageTemplate) Apply(ctx context.Context, mods ...MessageMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.Message
// according to the relationships in the template. Nothing is inserted into the db
func (t MessageTemplate) setModelRels(o *models.Message) {
	if t.r.MessageDeletions != nil {
		rel := models.MessageDeletionSlice{}
		for _, r := range t.r.MessageDeletions {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.MessageID = o.ID // h2
				rel.R.Message = o
			}
			rel = append(rel, related...)
		}
		o.R.MessageDeletions = rel
	}

	if t.r.MessageReactions != nil {
		rel := models.MessageReactionSlice{}
		for _, r := range t.r.MessageReactions {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.MessageID = o.ID // h2
				rel.R.Message = o
			}
			rel = append(rel, related...)
		}
		o.R.MessageReactions = rel
	}

	if t.r.MessageReceipts != nil {
		rel := models.MessageReceiptSlice{}
		for _, r := range t.r.MessageReceipts {
			related := r.o.BuildMany(r.number)
			for _, rel := range related {
				rel.MessageID = o.ID // h2
				rel.R.Message = o
			}
			rel = append(rel, related...)
		}
		o.R.MessageReceipts = rel
	}

	if t.r.Conversation != nil {
		rel := t.r.Conversation.o.Build()
		rel.R.Messages = append(rel.R.Messages, o)
		o.ConversationID = rel.ID // h2
		o.R.Conversation = rel
	}

	if t.r.SenderUser != nil {
		rel := t.r.SenderUser.o.Build()
		rel.R.SenderMessages = append(rel.R.SenderMessages, o)
		o.SenderID = rel.ID // h2
		o.R.SenderUser = rel
	}
}

// BuildSetter returns an *models.MessageSetter
// this does nothing with the relationship templates
func (o MessageTemplate) BuildSetter() *models.MessageSetter {
	m := &models.MessageSetter{}

	if o.ID != nil {
		val := o.ID()
		m.ID = omit.From(val)
	}
	if o.ConversationID != nil {
		val := o.ConversationID()
		m.ConversationID = omit.From(val)
	}
	if o.SenderID != nil {
		val := o.SenderID()
		m.SenderID = omit.From(val)
	}
	if o.ContentType != nil {
		val := o.ContentType()
		m.ContentType = omit.From(val)
	}
	if o.ContentText != nil {
		val := o.ContentText()
		m.ContentText = omitnull.FromNull(val)
	}
	if o.ContentMediaID != nil {
		val := o.ContentMediaID()
		m.ContentMediaID = omitnull.FromNull(val)
	}
	if o.ContentMediaURL != nil {
		val := o.ContentMediaURL()
		m.ContentMediaURL = omitnull.FromNull(val)
	}
	if o.ContentMetadata != nil {
		val := o.ContentMetadata()
		m.ContentMetadata = omitnull.FromNull(val)
	}
	if o.ReplyToID != nil {
		val := o.ReplyToID()
		m.ReplyToID = omitnull.FromNull(val)
	}
	if o.IsEdited != nil {
		val := o.IsEdited()
		m.IsEdited = omit.From(val)
	}
	if o.EditedAt != nil {
		val := o.EditedAt()
		m.EditedAt = omitnull.FromNull(val)
	}
	if o.DeletedForAll != nil {
		val := o.DeletedForAll()
		m.DeletedForAll = omit.From(val)
	}
	if o.CreatedAt != nil {
		val := o.CreatedAt()
		m.CreatedAt = omit.From(val)
	}

	return m
}

// BuildManySetter returns an []*models.MessageSetter
// this does nothing with the relationship templates
func (o MessageTemplate) BuildManySetter(number int) []*models.MessageSetter {
	m := make([]*models.MessageSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.Message
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use MessageTemplate.Create
func (o MessageTemplate) Build() *models.Message {
	m := &models.Message{}

	if o.ID != nil {
		m.ID = o.ID()
	}
	if o.ConversationID != nil {
		m.ConversationID = o.ConversationID()
	}
	if o.SenderID != nil {
		m.SenderID = o.SenderID()
	}
	if o.ContentType != nil {
		m.ContentType = o.ContentType()
	}
	if o.ContentText != nil {
		m.ContentText = o.ContentText()
	}
	if o.ContentMediaID != nil {
		m.ContentMediaID = o.ContentMediaID()
	}
	if o.ContentMediaURL != nil {
		m.ContentMediaURL = o.ContentMediaURL()
	}
	if o.ContentMetadata != nil {
		m.ContentMetadata = o.ContentMetadata()
	}
	if o.ReplyToID != nil {
		m.ReplyToID = o.ReplyToID()
	}
	if o.IsEdited != nil {
		m.IsEdited = o.IsEdited()
	}
	if o.EditedAt != nil {
		m.EditedAt = o.EditedAt()
	}
	if o.DeletedForAll != nil {
		m.DeletedForAll = o.DeletedForAll()
	}
	if o.CreatedAt != nil {
		m.CreatedAt = o.CreatedAt()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.MessageSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use MessageTemplate.CreateMany
func (o MessageTemplate) BuildMany(number int) models.MessageSlice {
	m := make(models.MessageSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableMessage(m *models.MessageSetter) {
	if !(m.ID.IsValue()) {
		val := random_uuid_UUID(nil)
		m.ID = omit.From(val)
	}
	if !(m.ConversationID.IsValue()) {
		val := random_uuid_UUID(nil)
		m.ConversationID = omit.From(val)
	}
	if !(m.SenderID.IsValue()) {
		val := random_uuid_UUID(nil)
		m.SenderID = omit.From(val)
	}
	if !(m.ContentType.IsValue()) {
		val := random_string(nil, "20")
		m.ContentType = omit.From(val)
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.Message
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *MessageTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.Message) error {
	var err error

	isMessageDeletionsDone, _ := messageRelMessageDeletionsCtx.Value(ctx)
	if !isMessageDeletionsDone && o.r.MessageDeletions != nil {
		ctx = messageRelMessageDeletionsCtx.WithValue(ctx, true)
		for _, r := range o.r.MessageDeletions {
			if r.o.alreadyPersisted {
				m.R.MessageDeletions = append(m.R.MessageDeletions, r.o.Build())
			} else {
				rel0, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachMessageDeletions(ctx, exec, rel0...)
				if err != nil {
					return err
				}
			}
		}
	}

	isMessageReactionsDone, _ := messageRelMessageReactionsCtx.Value(ctx)
	if !isMessageReactionsDone && o.r.MessageReactions != nil {
		ctx = messageRelMessageReactionsCtx.WithValue(ctx, true)
		for _, r := range o.r.MessageReactions {
			if r.o.alreadyPersisted {
				m.R.MessageReactions = append(m.R.MessageReactions, r.o.Build())
			} else {
				rel1, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachMessageReactions(ctx, exec, rel1...)
				if err != nil {
					return err
				}
			}
		}
	}

	isMessageReceiptsDone, _ := messageRelMessageReceiptsCtx.Value(ctx)
	if !isMessageReceiptsDone && o.r.MessageReceipts != nil {
		ctx = messageRelMessageReceiptsCtx.WithValue(ctx, true)
		for _, r := range o.r.MessageReceipts {
			if r.o.alreadyPersisted {
				m.R.MessageReceipts = append(m.R.MessageReceipts, r.o.Build())
			} else {
				rel2, err := r.o.CreateMany(ctx, exec, r.number)
				if err != nil {
					return err
				}

				err = m.AttachMessageReceipts(ctx, exec, rel2...)
				if err != nil {
					return err
				}
			}
		}
	}

	return err
}

// Create builds a message and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *MessageTemplate) Create(ctx context.Context, exec bob.Executor) (*models.Message, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableMessage(opt)

	if o.r.Conversation == nil {
		MessageMods.WithNewConversation().Apply(ctx, o)
	}

	var rel3 *models.Conversation

	if o.r.Conversation.o.alreadyPersisted {
		rel3 = o.r.Conversation.o.Build()
	} else {
		rel3, err = o.r.Conversation.o.Create(ctx, exec)
		if err != nil {
			return nil, err
		}
	}

	opt.ConversationID = omit.From(rel3.ID)

	if o.r.SenderUser == nil {
		MessageMods.WithNewSenderUser().Apply(ctx, o)
	}

	var rel4 *models.User

	if o.r.SenderUser.o.alreadyPersisted {
		rel4 = o.r.SenderUser.o.Build()
	} else {
		rel4, err = o.r.SenderUser.o.Create(ctx, exec)
		if err != nil {
			return nil, err
		}
	}

	opt.SenderID = omit.From(rel4.ID)

	m, err := models.Messages.Insert(opt).One(ctx, exec)
	if err != nil {
		return nil, err
	}

	m.R.Conversation = rel3
	m.R.SenderUser = rel4

	if err := o.insertOptRels(ctx, exec, m); err != nil {
		return nil, err
	}
	return m, err
}

// MustCreate builds a message and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *MessageTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.Message {
	m, err := o.Create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a message and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *MessageTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.Message {
	tb.Helper()
	m, err := o.Create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// CreateMany builds multiple messages and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o MessageTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.MessageSlice, error) {
	var err error
	m := make(models.MessageSlice, number)

	for i := range m {
		m[i], err = o.Create(ctx, exec)
		if err != nil {
			return nil, err
		}
	}

	return m, nil
}

// MustCreateMany builds multiple messages and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o MessageTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.MessageSlice {
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple messages and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o MessageTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.MessageSlice {
	tb.Helper()
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// Message has methods that act as mods for the MessageTemplate
var MessageMods messageMods

type messageMods struct{}

func (m messageMods) RandomizeAllColumns(f *faker.Faker) MessageMod {
	return MessageModSlice{
		MessageMods.RandomID(f),
		MessageMods.RandomConversationID(f),
		MessageMods.RandomSenderID(f),
		MessageMods.RandomContentType(f),
		MessageMods.RandomContentText(f),
		MessageMods.RandomContentMediaID(f),
		MessageMods.RandomContentMediaURL(f),
		MessageMods.RandomContentMetadata(f),
		MessageMods.RandomReplyToID(f),
		MessageMods.RandomIsEdited(f),
		MessageMods.RandomEditedAt(f),
		MessageMods.RandomDeletedForAll(f),
		MessageMods.RandomCreatedAt(f),
	}
}

// Set the model columns to this value
func (m messageMods) ID(val uuid.UUID) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m messageMods) IDFunc(f func() uuid.UUID) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ID = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetID() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m messageMods) RandomID(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ID = func() uuid.UUID {
			return random_uuid_UUID(f)
		}
	})
}

// Set the model columns to this value
func (m messageMods) ConversationID(val uuid.UUID) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ConversationID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m messageMods) ConversationIDFunc(f func() uuid.UUID) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ConversationID = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetConversationID() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ConversationID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m messageMods) RandomConversationID(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ConversationID = func() uuid.UUID {
			return random_uuid_UUID(f)
		}
	})
}

// Set the model columns to this value
func (m messageMods) SenderID(val uuid.UUID) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.SenderID = func() uuid.UUID { return val }
	})
}

// Set the Column from the function
func (m messageMods) SenderIDFunc(f func() uuid.UUID) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.SenderID = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetSenderID() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.SenderID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m messageMods) RandomSenderID(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.SenderID = func() uuid.UUID {
			return random_uuid_UUID(f)
		}
	})
}

// Set the model columns to this value
func (m messageMods) ContentType(val string) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentType = func() string { return val }
	})
}

// Set the Column from the function
func (m messageMods) ContentTypeFunc(f func() string) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentType = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetContentType() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentType = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m messageMods) RandomContentType(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentType = func() string {
			return random_string(f, "20")
		}
	})
}

// Set the model columns to this value
func (m messageMods) ContentText(val null.Val[string]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentText = func() null.Val[string] { return val }
	})
}

// Set the Column from the function
func (m messageMods) ContentTextFunc(f func() null.Val[string]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentText = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetContentText() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentText = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m messageMods) RandomContentText(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentText = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m messageMods) RandomContentTextNotNull(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentText = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m messageMods) ContentMediaID(val null.Val[uuid.UUID]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaID = func() null.Val[uuid.UUID] { return val }
	})
}

// Set the Column from the function
func (m messageMods) ContentMediaIDFunc(f func() null.Val[uuid.UUID]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaID = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetContentMediaID() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m messageMods) RandomContentMediaID(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaID = func() null.Val[uuid.UUID] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_uuid_UUID(f)
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m messageMods) RandomContentMediaIDNotNull(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaID = func() null.Val[uuid.UUID] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_uuid_UUID(f)
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m messageMods) ContentMediaURL(val null.Val[string]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaURL = func() null.Val[string] { return val }
	})
}

// Set the Column from the function
func (m messageMods) ContentMediaURLFunc(f func() null.Val[string]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaURL = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetContentMediaURL() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaURL = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m messageMods) RandomContentMediaURL(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaURL = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m messageMods) RandomContentMediaURLNotNull(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMediaURL = func() null.Val[string] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_string(f)
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m messageMods) ContentMetadata(val null.Val[types.JSON[json.RawMessage]]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMetadata = func() null.Val[types.JSON[json.RawMessage]] { return val }
	})
}

// Set the Column from the function
func (m messageMods) ContentMetadataFunc(f func() null.Val[types.JSON[json.RawMessage]]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMetadata = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetContentMetadata() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMetadata = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m messageMods) RandomContentMetadata(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMetadata = func() null.Val[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m messageMods) RandomContentMetadataNotNull(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ContentMetadata = func() null.Val[types.JSON[json.RawMessage]] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_types_JSON_json_RawMessage_(f)
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m messageMods) ReplyToID(val null.Val[uuid.UUID]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ReplyToID = func() null.Val[uuid.UUID] { return val }
	})
}

// Set the Column from the function
func (m messageMods) ReplyToIDFunc(f func() null.Val[uuid.UUID]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ReplyToID = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetReplyToID() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ReplyToID = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m messageMods) RandomReplyToID(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ReplyToID = func() null.Val[uuid.UUID] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_uuid_UUID(f)
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m messageMods) RandomReplyToIDNotNull(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.ReplyToID = func() null.Val[uuid.UUID] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_uuid_UUID(f)
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m messageMods) IsEdited(val bool) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.IsEdited = func() bool { return val }
	})
}

// Set the Column from the function
func (m messageMods) IsEditedFunc(f func() bool) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.IsEdited = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetIsEdited() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.IsEdited = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m messageMods) RandomIsEdited(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.IsEdited = func() bool {
			return random_bool(f)
		}
	})
}

// Set the model columns to this value
func (m messageMods) EditedAt(val null.Val[time.Time]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.EditedAt = func() null.Val[time.Time] { return val }
	})
}

// Set the Column from the function
func (m messageMods) EditedAtFunc(f func() null.Val[time.Time]) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.EditedAt = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetEditedAt() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.EditedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is sometimes null
func (m messageMods) RandomEditedAt(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.EditedAt = func() null.Val[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return null.From(val)
		}
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
// The generated value is never null
func (m messageMods) RandomEditedAtNotNull(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.EditedAt = func() null.Val[time.Time] {
			if f == nil {
				f = &defaultFaker
			}

			val := random_time_Time(f)
			return null.From(val)
		}
	})
}

// Set the model columns to this value
func (m messageMods) DeletedForAll(val bool) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.DeletedForAll = func() bool { return val }
	})
}

// Set the Column from the function
func (m messageMods) DeletedForAllFunc(f func() bool) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.DeletedForAll = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetDeletedForAll() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.DeletedForAll = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m messageMods) RandomDeletedForAll(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.DeletedForAll = func() bool {
			return random_bool(f)
		}
	})
}

// Set the model columns to this value
func (m messageMods) CreatedAt(val time.Time) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.CreatedAt = func() time.Time { return val }
	})
}

// Set the Column from the function
func (m messageMods) CreatedAtFunc(f func() time.Time) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.CreatedAt = f
	})
}

// Clear any values for the column
func (m messageMods) UnsetCreatedAt() MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.CreatedAt = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m messageMods) RandomCreatedAt(f *faker.Faker) MessageMod {
	return MessageModFunc(func(_ context.Context, o *MessageTemplate) {
		o.CreatedAt = func() time.Time {
			return random_time_Time(f)
		}
	})
}

func (m messageMods) WithParentsCascading() MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		if isDone, _ := messageWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = messageWithParentsCascadingCtx.WithValue(ctx, true)
		{

			related := o.f.NewConversationWithContext(ctx, ConversationMods.WithParentsCascading())
			m.WithConversation(related).Apply(ctx, o)
		}
		{

			related := o.f.NewUserWithContext(ctx, UserMods.WithParentsCascading())
			m.WithSenderUser(related).Apply(ctx, o)
		}
	})
}

func (m messageMods) WithConversation(rel *ConversationTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.Conversation = &messageRConversationR{
			o: rel,
		}
	})
}

func (m messageMods) WithNewConversation(mods ...ConversationMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewConversationWithContext(ctx, mods...)

		m.WithConversation(related).Apply(ctx, o)
	})
}

func (m messageMods) WithExistingConversation(em *models.Conversation) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.Conversation = &messageRConversationR{
			o: o.f.FromExistingConversation(em),
		}
	})
}

func (m messageMods) WithoutConversation() MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.Conversation = nil
	})
}

func (m messageMods) WithSenderUser(rel *UserTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.SenderUser = &messageRSenderUserR{
			o: rel,
		}
	})
}

func (m messageMods) WithNewSenderUser(mods ...UserMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewUserWithContext(ctx, mods...)

		m.WithSenderUser(related).Apply(ctx, o)
	})
}

func (m messageMods) WithExistingSenderUser(em *models.User) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.SenderUser = &messageRSenderUserR{
			o: o.f.FromExistingUser(em),
		}
	})
}

func (m messageMods) WithoutSenderUser() MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.SenderUser = nil
	})
}

func (m messageMods) WithMessageDeletions(number int, related *MessageDeletionTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageDeletions = []*messageRMessageDeletionsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m messageMods) WithNewMessageDeletions(number int, mods ...MessageDeletionMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewMessageDeletionWithContext(ctx, mods...)
		m.WithMessageDeletions(number, related).Apply(ctx, o)
	})
}

func (m messageMods) AddMessageDeletions(number int, related *MessageDeletionTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageDeletions = append(o.r.MessageDeletions, &messageRMessageDeletionsR{
			number: number,
			o:      related,
		})
	})
}

func (m messageMods) AddNewMessageDeletions(number int, mods ...MessageDeletionMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewMessageDeletionWithContext(ctx, mods...)
		m.AddMessageDeletions(number, related).Apply(ctx, o)
	})
}

func (m messageMods) AddExistingMessageDeletions(existingModels ...*models.MessageDeletion) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		for _, em := range existingModels {
			o.r.MessageDeletions = append(o.r.MessageDeletions, &messageRMessageDeletionsR{
				o: o.f.FromExistingMessageDeletion(em),
			})
		}
	})
}

func (m messageMods) WithoutMessageDeletions() MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageDeletions = nil
	})
}

func (m messageMods) WithMessageReactions(number int, related *MessageReactionTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageReactions = []*messageRMessageReactionsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m messageMods) WithNewMessageReactions(number int, mods ...MessageReactionMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewMessageReactionWithContext(ctx, mods...)
		m.WithMessageReactions(number, related).Apply(ctx, o)
	})
}

func (m messageMods) AddMessageReactions(number int, related *MessageReactionTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageReactions = append(o.r.MessageReactions, &messageRMessageReactionsR{
			number: number,
			o:      related,
		})
	})
}

func (m messageMods) AddNewMessageReactions(number int, mods ...MessageReactionMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewMessageReactionWithContext(ctx, mods...)
		m.AddMessageReactions(number, related).Apply(ctx, o)
	})
}

func (m messageMods) AddExistingMessageReactions(existingModels ...*models.MessageReaction) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		for _, em := range existingModels {
			o.r.MessageReactions = append(o.r.MessageReactions, &messageRMessageReactionsR{
				o: o.f.FromExistingMessageReaction(em),
			})
		}
	})
}

func (m messageMods) WithoutMessageReactions() MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageReactions = nil
	})
}

func (m messageMods) WithMessageReceipts(number int, related *MessageReceiptTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageReceipts = []*messageRMessageReceiptsR{{
			number: number,
			o:      related,
		}}
	})
}

func (m messageMods) WithNewMessageReceipts(number int, mods ...MessageReceiptMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewMessageReceiptWithContext(ctx, mods...)
		m.WithMessageReceipts(number, related).Apply(ctx, o)
	})
}

func (m messageMods) AddMessageReceipts(number int, related *MessageReceiptTemplate) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageReceipts = append(o.r.MessageReceipts, &messageRMessageReceiptsR{
			number: number,
			o:      related,
		})
	})
}

func (m messageMods) AddNewMessageReceipts(number int, mods ...MessageReceiptMod) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		related := o.f.NewMessageReceiptWithContext(ctx, mods...)
		m.AddMessageReceipts(number, related).Apply(ctx, o)
	})
}

func (m messageMods) AddExistingMessageReceipts(existingModels ...*models.MessageReceipt) MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		for _, em := range existingModels {
			o.r.MessageReceipts = append(o.r.MessageReceipts, &messageRMessageReceiptsR{
				o: o.f.FromExistingMessageReceipt(em),
			})
		}
	})
}

func (m messageMods) WithoutMessageReceipts() MessageMod {
	return MessageModFunc(func(ctx context.Context, o *MessageTemplate) {
		o.r.MessageReceipts = nil
	})
}
