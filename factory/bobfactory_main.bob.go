// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"encoding/json"
	"time"

	"github.com/aarondl/opt/null"
	models "github.com/danielng/kin-core-svc/models"
	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob/types"
)

type Factory struct {
	baseAvailabilityAutoRuleMods    AvailabilityAutoRuleModSlice
	baseAvailabilityWindowMods      AvailabilityWindowModSlice
	baseCheckInMods                 CheckInModSlice
	baseCircleInvitationMods        CircleInvitationModSlice
	baseCircleMemberMods            CircleMemberModSlice
	baseCircleSharingPreferenceMods CircleSharingPreferenceModSlice
	baseCircleMods                  CircleModSlice
	baseContactRequestMods          ContactRequestModSlice
	baseContactMods                 ContactModSlice
	baseConversationParticipantMods ConversationParticipantModSlice
	baseConversationMods            ConversationModSlice
	baseLocationHistoryMods         LocationHistoryModSlice
	baseMediumMods                  MediumModSlice
	baseMessageDeletionMods         MessageDeletionModSlice
	baseMessageReactionMods         MessageReactionModSlice
	baseMessageReceiptMods          MessageReceiptModSlice
	baseMessageMods                 MessageModSlice
	basePlaceMods                   PlaceModSlice
	baseUserAvailabilityMods        UserAvailabilityModSlice
	baseUserLocationMods            UserLocationModSlice
	baseUserPreferenceMods          UserPreferenceModSlice
	baseUserMods                    UserModSlice
}

func New() *Factory {
	return &Factory{}
}

func (f *Factory) NewAvailabilityAutoRule(mods ...AvailabilityAutoRuleMod) *AvailabilityAutoRuleTemplate {
	return f.NewAvailabilityAutoRuleWithContext(context.Background(), mods...)
}

func (f *Factory) NewAvailabilityAutoRuleWithContext(ctx context.Context, mods ...AvailabilityAutoRuleMod) *AvailabilityAutoRuleTemplate {
	o := &AvailabilityAutoRuleTemplate{f: f}

	if f != nil {
		f.baseAvailabilityAutoRuleMods.Apply(ctx, o)
	}

	AvailabilityAutoRuleModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingAvailabilityAutoRule(m *models.AvailabilityAutoRule) *AvailabilityAutoRuleTemplate {
	o := &AvailabilityAutoRuleTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Name = func() string { return m.Name }
	o.Condition = func() types.JSON[json.RawMessage] { return m.Condition }
	o.TargetStatus = func() string { return m.TargetStatus }
	o.Priority = func() int32 { return m.Priority }
	o.IsActive = func() bool { return m.IsActive }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.User != nil {
		AvailabilityAutoRuleMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewAvailabilityWindow(mods ...AvailabilityWindowMod) *AvailabilityWindowTemplate {
	return f.NewAvailabilityWindowWithContext(context.Background(), mods...)
}

func (f *Factory) NewAvailabilityWindowWithContext(ctx context.Context, mods ...AvailabilityWindowMod) *AvailabilityWindowTemplate {
	o := &AvailabilityWindowTemplate{f: f}

	if f != nil {
		f.baseAvailabilityWindowMods.Apply(ctx, o)
	}

	AvailabilityWindowModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingAvailabilityWindow(m *models.AvailabilityWindow) *AvailabilityWindowTemplate {
	o := &AvailabilityWindowTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Name = func() string { return m.Name }
	o.Weekday = func() int16 { return m.Weekday }
	o.StartTime = func() string { return m.StartTime }
	o.EndTime = func() string { return m.EndTime }
	o.Status = func() string { return m.Status }
	o.IsActive = func() bool { return m.IsActive }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.User != nil {
		AvailabilityWindowMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewCheckIn(mods ...CheckInMod) *CheckInTemplate {
	return f.NewCheckInWithContext(context.Background(), mods...)
}

func (f *Factory) NewCheckInWithContext(ctx context.Context, mods ...CheckInMod) *CheckInTemplate {
	o := &CheckInTemplate{f: f}

	if f != nil {
		f.baseCheckInMods.Apply(ctx, o)
	}

	CheckInModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingCheckIn(m *models.CheckIn) *CheckInTemplate {
	o := &CheckInTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.PlaceID = func() uuid.UUID { return m.PlaceID }
	o.Type = func() string { return m.Type }
	o.Latitude = func() float64 { return m.Latitude }
	o.Longitude = func() float64 { return m.Longitude }
	o.Note = func() null.Val[string] { return m.Note }
	o.AutoCheck = func() bool { return m.AutoCheck }
	o.CreatedAt = func() time.Time { return m.CreatedAt }

	ctx := context.Background()
	if m.R.Place != nil {
		CheckInMods.WithExistingPlace(m.R.Place).Apply(ctx, o)
	}
	if m.R.User != nil {
		CheckInMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewCircleInvitation(mods ...CircleInvitationMod) *CircleInvitationTemplate {
	return f.NewCircleInvitationWithContext(context.Background(), mods...)
}

func (f *Factory) NewCircleInvitationWithContext(ctx context.Context, mods ...CircleInvitationMod) *CircleInvitationTemplate {
	o := &CircleInvitationTemplate{f: f}

	if f != nil {
		f.baseCircleInvitationMods.Apply(ctx, o)
	}

	CircleInvitationModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingCircleInvitation(m *models.CircleInvitation) *CircleInvitationTemplate {
	o := &CircleInvitationTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.CircleID = func() uuid.UUID { return m.CircleID }
	o.InviterID = func() uuid.UUID { return m.InviterID }
	o.InviteeID = func() null.Val[uuid.UUID] { return m.InviteeID }
	o.Type = func() string { return m.Type }
	o.Code = func() string { return m.Code }
	o.Status = func() string { return m.Status }
	o.MaxUses = func() null.Val[int32] { return m.MaxUses }
	o.UseCount = func() int32 { return m.UseCount }
	o.ExpiresAt = func() null.Val[time.Time] { return m.ExpiresAt }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Circle != nil {
		CircleInvitationMods.WithExistingCircle(m.R.Circle).Apply(ctx, o)
	}
	if m.R.InviteeUser != nil {
		CircleInvitationMods.WithExistingInviteeUser(m.R.InviteeUser).Apply(ctx, o)
	}
	if m.R.InviterUser != nil {
		CircleInvitationMods.WithExistingInviterUser(m.R.InviterUser).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewCircleMember(mods ...CircleMemberMod) *CircleMemberTemplate {
	return f.NewCircleMemberWithContext(context.Background(), mods...)
}

func (f *Factory) NewCircleMemberWithContext(ctx context.Context, mods ...CircleMemberMod) *CircleMemberTemplate {
	o := &CircleMemberTemplate{f: f}

	if f != nil {
		f.baseCircleMemberMods.Apply(ctx, o)
	}

	CircleMemberModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingCircleMember(m *models.CircleMember) *CircleMemberTemplate {
	o := &CircleMemberTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.CircleID = func() uuid.UUID { return m.CircleID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Role = func() string { return m.Role }
	o.Nickname = func() null.Val[string] { return m.Nickname }
	o.JoinedAt = func() time.Time { return m.JoinedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Circle != nil {
		CircleMemberMods.WithExistingCircle(m.R.Circle).Apply(ctx, o)
	}
	if m.R.User != nil {
		CircleMemberMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewCircleSharingPreference(mods ...CircleSharingPreferenceMod) *CircleSharingPreferenceTemplate {
	return f.NewCircleSharingPreferenceWithContext(context.Background(), mods...)
}

func (f *Factory) NewCircleSharingPreferenceWithContext(ctx context.Context, mods ...CircleSharingPreferenceMod) *CircleSharingPreferenceTemplate {
	o := &CircleSharingPreferenceTemplate{f: f}

	if f != nil {
		f.baseCircleSharingPreferenceMods.Apply(ctx, o)
	}

	CircleSharingPreferenceModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingCircleSharingPreference(m *models.CircleSharingPreference) *CircleSharingPreferenceTemplate {
	o := &CircleSharingPreferenceTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.CircleID = func() uuid.UUID { return m.CircleID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.PrivacyLevel = func() string { return m.PrivacyLevel }
	o.ShareTimezone = func() bool { return m.ShareTimezone }
	o.ShareAvailability = func() bool { return m.ShareAvailability }
	o.ShareLocation = func() bool { return m.ShareLocation }
	o.LocationPrecision = func() string { return m.LocationPrecision }
	o.ShareActivity = func() bool { return m.ShareActivity }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Circle != nil {
		CircleSharingPreferenceMods.WithExistingCircle(m.R.Circle).Apply(ctx, o)
	}
	if m.R.User != nil {
		CircleSharingPreferenceMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewCircle(mods ...CircleMod) *CircleTemplate {
	return f.NewCircleWithContext(context.Background(), mods...)
}

func (f *Factory) NewCircleWithContext(ctx context.Context, mods ...CircleMod) *CircleTemplate {
	o := &CircleTemplate{f: f}

	if f != nil {
		f.baseCircleMods.Apply(ctx, o)
	}

	CircleModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingCircle(m *models.Circle) *CircleTemplate {
	o := &CircleTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.Name = func() string { return m.Name }
	o.Description = func() null.Val[string] { return m.Description }
	o.Avatar = func() null.Val[string] { return m.Avatar }
	o.CreatedBy = func() uuid.UUID { return m.CreatedBy }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.CircleInvitations) > 0 {
		CircleMods.AddExistingCircleInvitations(m.R.CircleInvitations...).Apply(ctx, o)
	}
	if len(m.R.CircleMembers) > 0 {
		CircleMods.AddExistingCircleMembers(m.R.CircleMembers...).Apply(ctx, o)
	}
	if len(m.R.CircleSharingPreferences) > 0 {
		CircleMods.AddExistingCircleSharingPreferences(m.R.CircleSharingPreferences...).Apply(ctx, o)
	}
	if m.R.CreatedByUser != nil {
		CircleMods.WithExistingCreatedByUser(m.R.CreatedByUser).Apply(ctx, o)
	}
	if len(m.R.Conversations) > 0 {
		CircleMods.AddExistingConversations(m.R.Conversations...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewContactRequest(mods ...ContactRequestMod) *ContactRequestTemplate {
	return f.NewContactRequestWithContext(context.Background(), mods...)
}

func (f *Factory) NewContactRequestWithContext(ctx context.Context, mods ...ContactRequestMod) *ContactRequestTemplate {
	o := &ContactRequestTemplate{f: f}

	if f != nil {
		f.baseContactRequestMods.Apply(ctx, o)
	}

	ContactRequestModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingContactRequest(m *models.ContactRequest) *ContactRequestTemplate {
	o := &ContactRequestTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.FromUserID = func() uuid.UUID { return m.FromUserID }
	o.ToUserID = func() uuid.UUID { return m.ToUserID }
	o.Message = func() null.Val[string] { return m.Message }
	o.Status = func() string { return m.Status }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.FromUserUser != nil {
		ContactRequestMods.WithExistingFromUserUser(m.R.FromUserUser).Apply(ctx, o)
	}
	if m.R.ToUserUser != nil {
		ContactRequestMods.WithExistingToUserUser(m.R.ToUserUser).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewContact(mods ...ContactMod) *ContactTemplate {
	return f.NewContactWithContext(context.Background(), mods...)
}

func (f *Factory) NewContactWithContext(ctx context.Context, mods ...ContactMod) *ContactTemplate {
	o := &ContactTemplate{f: f}

	if f != nil {
		f.baseContactMods.Apply(ctx, o)
	}

	ContactModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingContact(m *models.Contact) *ContactTemplate {
	o := &ContactTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.ContactID = func() uuid.UUID { return m.ContactID }
	o.Nickname = func() null.Val[string] { return m.Nickname }
	o.IsFavorite = func() bool { return m.IsFavorite }
	o.IsBlocked = func() bool { return m.IsBlocked }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.ContactUser != nil {
		ContactMods.WithExistingContactUser(m.R.ContactUser).Apply(ctx, o)
	}
	if m.R.User != nil {
		ContactMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewConversationParticipant(mods ...ConversationParticipantMod) *ConversationParticipantTemplate {
	return f.NewConversationParticipantWithContext(context.Background(), mods...)
}

func (f *Factory) NewConversationParticipantWithContext(ctx context.Context, mods ...ConversationParticipantMod) *ConversationParticipantTemplate {
	o := &ConversationParticipantTemplate{f: f}

	if f != nil {
		f.baseConversationParticipantMods.Apply(ctx, o)
	}

	ConversationParticipantModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingConversationParticipant(m *models.ConversationParticipant) *ConversationParticipantTemplate {
	o := &ConversationParticipantTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.ConversationID = func() uuid.UUID { return m.ConversationID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.IsMuted = func() bool { return m.IsMuted }
	o.IsArchived = func() bool { return m.IsArchived }
	o.LastReadAt = func() null.Val[time.Time] { return m.LastReadAt }
	o.JoinedAt = func() time.Time { return m.JoinedAt }
	o.LeftAt = func() null.Val[time.Time] { return m.LeftAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Conversation != nil {
		ConversationParticipantMods.WithExistingConversation(m.R.Conversation).Apply(ctx, o)
	}
	if m.R.User != nil {
		ConversationParticipantMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewConversation(mods ...ConversationMod) *ConversationTemplate {
	return f.NewConversationWithContext(context.Background(), mods...)
}

func (f *Factory) NewConversationWithContext(ctx context.Context, mods ...ConversationMod) *ConversationTemplate {
	o := &ConversationTemplate{f: f}

	if f != nil {
		f.baseConversationMods.Apply(ctx, o)
	}

	ConversationModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingConversation(m *models.Conversation) *ConversationTemplate {
	o := &ConversationTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.Type = func() string { return m.Type }
	o.CircleID = func() null.Val[uuid.UUID] { return m.CircleID }
	o.Name = func() null.Val[string] { return m.Name }
	o.Avatar = func() null.Val[string] { return m.Avatar }
	o.LastMessageID = func() null.Val[uuid.UUID] { return m.LastMessageID }
	o.LastMessageAt = func() null.Val[time.Time] { return m.LastMessageAt }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.ConversationParticipants) > 0 {
		ConversationMods.AddExistingConversationParticipants(m.R.ConversationParticipants...).Apply(ctx, o)
	}
	if m.R.Circle != nil {
		ConversationMods.WithExistingCircle(m.R.Circle).Apply(ctx, o)
	}
	if len(m.R.Messages) > 0 {
		ConversationMods.AddExistingMessages(m.R.Messages...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewLocationHistory(mods ...LocationHistoryMod) *LocationHistoryTemplate {
	return f.NewLocationHistoryWithContext(context.Background(), mods...)
}

func (f *Factory) NewLocationHistoryWithContext(ctx context.Context, mods ...LocationHistoryMod) *LocationHistoryTemplate {
	o := &LocationHistoryTemplate{f: f}

	if f != nil {
		f.baseLocationHistoryMods.Apply(ctx, o)
	}

	LocationHistoryModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingLocationHistory(m *models.LocationHistory) *LocationHistoryTemplate {
	o := &LocationHistoryTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Latitude = func() float64 { return m.Latitude }
	o.Longitude = func() float64 { return m.Longitude }
	o.Accuracy = func() null.Val[float64] { return m.Accuracy }
	o.PlaceID = func() null.Val[uuid.UUID] { return m.PlaceID }
	o.CreatedAt = func() time.Time { return m.CreatedAt }

	ctx := context.Background()
	if m.R.User != nil {
		LocationHistoryMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewMedium(mods ...MediumMod) *MediumTemplate {
	return f.NewMediumWithContext(context.Background(), mods...)
}

func (f *Factory) NewMediumWithContext(ctx context.Context, mods ...MediumMod) *MediumTemplate {
	o := &MediumTemplate{f: f}

	if f != nil {
		f.baseMediumMods.Apply(ctx, o)
	}

	MediumModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingMedium(m *models.Medium) *MediumTemplate {
	o := &MediumTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Type = func() string { return m.Type }
	o.FileName = func() string { return m.FileName }
	o.FileSize = func() int64 { return m.FileSize }
	o.MimeType = func() string { return m.MimeType }
	o.StorageKey = func() string { return m.StorageKey }
	o.URL = func() string { return m.URL }
	o.ThumbnailKey = func() null.Val[string] { return m.ThumbnailKey }
	o.ThumbnailURL = func() null.Val[string] { return m.ThumbnailURL }
	o.Width = func() null.Val[int32] { return m.Width }
	o.Height = func() null.Val[int32] { return m.Height }
	o.Duration = func() null.Val[int32] { return m.Duration }
	o.CreatedAt = func() time.Time { return m.CreatedAt }

	ctx := context.Background()
	if m.R.User != nil {
		MediumMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewMessageDeletion(mods ...MessageDeletionMod) *MessageDeletionTemplate {
	return f.NewMessageDeletionWithContext(context.Background(), mods...)
}

func (f *Factory) NewMessageDeletionWithContext(ctx context.Context, mods ...MessageDeletionMod) *MessageDeletionTemplate {
	o := &MessageDeletionTemplate{f: f}

	if f != nil {
		f.baseMessageDeletionMods.Apply(ctx, o)
	}

	MessageDeletionModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingMessageDeletion(m *models.MessageDeletion) *MessageDeletionTemplate {
	o := &MessageDeletionTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.MessageID = func() uuid.UUID { return m.MessageID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.DeletedAt = func() time.Time { return m.DeletedAt }

	ctx := context.Background()
	if m.R.Message != nil {
		MessageDeletionMods.WithExistingMessage(m.R.Message).Apply(ctx, o)
	}
	if m.R.User != nil {
		MessageDeletionMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewMessageReaction(mods ...MessageReactionMod) *MessageReactionTemplate {
	return f.NewMessageReactionWithContext(context.Background(), mods...)
}

func (f *Factory) NewMessageReactionWithContext(ctx context.Context, mods ...MessageReactionMod) *MessageReactionTemplate {
	o := &MessageReactionTemplate{f: f}

	if f != nil {
		f.baseMessageReactionMods.Apply(ctx, o)
	}

	MessageReactionModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingMessageReaction(m *models.MessageReaction) *MessageReactionTemplate {
	o := &MessageReactionTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.MessageID = func() uuid.UUID { return m.MessageID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Emoji = func() string { return m.Emoji }
	o.CreatedAt = func() time.Time { return m.CreatedAt }

	ctx := context.Background()
	if m.R.Message != nil {
		MessageReactionMods.WithExistingMessage(m.R.Message).Apply(ctx, o)
	}
	if m.R.User != nil {
		MessageReactionMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewMessageReceipt(mods ...MessageReceiptMod) *MessageReceiptTemplate {
	return f.NewMessageReceiptWithContext(context.Background(), mods...)
}

func (f *Factory) NewMessageReceiptWithContext(ctx context.Context, mods ...MessageReceiptMod) *MessageReceiptTemplate {
	o := &MessageReceiptTemplate{f: f}

	if f != nil {
		f.baseMessageReceiptMods.Apply(ctx, o)
	}

	MessageReceiptModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingMessageReceipt(m *models.MessageReceipt) *MessageReceiptTemplate {
	o := &MessageReceiptTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.MessageID = func() uuid.UUID { return m.MessageID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Status = func() string { return m.Status }
	o.DeliveredAt = func() null.Val[time.Time] { return m.DeliveredAt }
	o.ReadAt = func() null.Val[time.Time] { return m.ReadAt }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Message != nil {
		MessageReceiptMods.WithExistingMessage(m.R.Message).Apply(ctx, o)
	}
	if m.R.User != nil {
		MessageReceiptMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewMessage(mods ...MessageMod) *MessageTemplate {
	return f.NewMessageWithContext(context.Background(), mods...)
}

func (f *Factory) NewMessageWithContext(ctx context.Context, mods ...MessageMod) *MessageTemplate {
	o := &MessageTemplate{f: f}

	if f != nil {
		f.baseMessageMods.Apply(ctx, o)
	}

	MessageModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingMessage(m *models.Message) *MessageTemplate {
	o := &MessageTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.ConversationID = func() uuid.UUID { return m.ConversationID }
	o.SenderID = func() uuid.UUID { return m.SenderID }
	o.ContentType = func() string { return m.ContentType }
	o.ContentText = func() null.Val[string] { return m.ContentText }
	o.ContentMediaID = func() null.Val[uuid.UUID] { return m.ContentMediaID }
	o.ContentMediaURL = func() null.Val[string] { return m.ContentMediaURL }
	o.ContentMetadata = func() null.Val[types.JSON[json.RawMessage]] { return m.ContentMetadata }
	o.ReplyToID = func() null.Val[uuid.UUID] { return m.ReplyToID }
	o.IsEdited = func() bool { return m.IsEdited }
	o.EditedAt = func() null.Val[time.Time] { return m.EditedAt }
	o.DeletedForAll = func() bool { return m.DeletedForAll }
	o.CreatedAt = func() time.Time { return m.CreatedAt }

	ctx := context.Background()
	if len(m.R.MessageDeletions) > 0 {
		MessageMods.AddExistingMessageDeletions(m.R.MessageDeletions...).Apply(ctx, o)
	}
	if len(m.R.MessageReactions) > 0 {
		MessageMods.AddExistingMessageReactions(m.R.MessageReactions...).Apply(ctx, o)
	}
	if len(m.R.MessageReceipts) > 0 {
		MessageMods.AddExistingMessageReceipts(m.R.MessageReceipts...).Apply(ctx, o)
	}
	if m.R.Conversation != nil {
		MessageMods.WithExistingConversation(m.R.Conversation).Apply(ctx, o)
	}
	if m.R.SenderUser != nil {
		MessageMods.WithExistingSenderUser(m.R.SenderUser).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewPlace(mods ...PlaceMod) *PlaceTemplate {
	return f.NewPlaceWithContext(context.Background(), mods...)
}

func (f *Factory) NewPlaceWithContext(ctx context.Context, mods ...PlaceMod) *PlaceTemplate {
	o := &PlaceTemplate{f: f}

	if f != nil {
		f.basePlaceMods.Apply(ctx, o)
	}

	PlaceModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingPlace(m *models.Place) *PlaceTemplate {
	o := &PlaceTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.UserID = func() uuid.UUID { return m.UserID }
	o.Name = func() string { return m.Name }
	o.Type = func() string { return m.Type }
	o.Latitude = func() float64 { return m.Latitude }
	o.Longitude = func() float64 { return m.Longitude }
	o.Radius = func() float64 { return m.Radius }
	o.Address = func() null.Val[string] { return m.Address }
	o.Icon = func() null.Val[string] { return m.Icon }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.CheckIns) > 0 {
		PlaceMods.AddExistingCheckIns(m.R.CheckIns...).Apply(ctx, o)
	}
	if m.R.User != nil {
		PlaceMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewUserAvailability(mods ...UserAvailabilityMod) *UserAvailabilityTemplate {
	return f.NewUserAvailabilityWithContext(context.Background(), mods...)
}

func (f *Factory) NewUserAvailabilityWithContext(ctx context.Context, mods ...UserAvailabilityMod) *UserAvailabilityTemplate {
	o := &UserAvailabilityTemplate{f: f}

	if f != nil {
		f.baseUserAvailabilityMods.Apply(ctx, o)
	}

	UserAvailabilityModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingUserAvailability(m *models.UserAvailability) *UserAvailabilityTemplate {
	o := &UserAvailabilityTemplate{f: f, alreadyPersisted: true}

	o.UserID = func() uuid.UUID { return m.UserID }
	o.Status = func() string { return m.Status }
	o.StatusMessage = func() null.Val[string] { return m.StatusMessage }
	o.ManualUntil = func() null.Val[time.Time] { return m.ManualUntil }
	o.AutoStatus = func() bool { return m.AutoStatus }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.User != nil {
		UserAvailabilityMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewUserLocation(mods ...UserLocationMod) *UserLocationTemplate {
	return f.NewUserLocationWithContext(context.Background(), mods...)
}

func (f *Factory) NewUserLocationWithContext(ctx context.Context, mods ...UserLocationMod) *UserLocationTemplate {
	o := &UserLocationTemplate{f: f}

	if f != nil {
		f.baseUserLocationMods.Apply(ctx, o)
	}

	UserLocationModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingUserLocation(m *models.UserLocation) *UserLocationTemplate {
	o := &UserLocationTemplate{f: f, alreadyPersisted: true}

	o.UserID = func() uuid.UUID { return m.UserID }
	o.Latitude = func() float64 { return m.Latitude }
	o.Longitude = func() float64 { return m.Longitude }
	o.Accuracy = func() null.Val[float64] { return m.Accuracy }
	o.Altitude = func() null.Val[float64] { return m.Altitude }
	o.Speed = func() null.Val[float64] { return m.Speed }
	o.Heading = func() null.Val[float64] { return m.Heading }
	o.PlaceID = func() null.Val[uuid.UUID] { return m.PlaceID }
	o.Country = func() null.Val[string] { return m.Country }
	o.City = func() null.Val[string] { return m.City }
	o.Neighborhood = func() null.Val[string] { return m.Neighborhood }
	o.Address = func() null.Val[string] { return m.Address }
	o.IsMoving = func() bool { return m.IsMoving }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.User != nil {
		UserLocationMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewUserPreference(mods ...UserPreferenceMod) *UserPreferenceTemplate {
	return f.NewUserPreferenceWithContext(context.Background(), mods...)
}

func (f *Factory) NewUserPreferenceWithContext(ctx context.Context, mods ...UserPreferenceMod) *UserPreferenceTemplate {
	o := &UserPreferenceTemplate{f: f}

	if f != nil {
		f.baseUserPreferenceMods.Apply(ctx, o)
	}

	UserPreferenceModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingUserPreference(m *models.UserPreference) *UserPreferenceTemplate {
	o := &UserPreferenceTemplate{f: f, alreadyPersisted: true}

	o.UserID = func() uuid.UUID { return m.UserID }
	o.DefaultPrivacyLevel = func() string { return m.DefaultPrivacyLevel }
	o.ShowOnlineStatus = func() bool { return m.ShowOnlineStatus }
	o.ShowLastSeen = func() bool { return m.ShowLastSeen }
	o.ShowReadReceipts = func() bool { return m.ShowReadReceipts }
	o.AllowContactDiscovery = func() bool { return m.AllowContactDiscovery }
	o.PushNotifications = func() bool { return m.PushNotifications }
	o.EmailNotifications = func() bool { return m.EmailNotifications }
	o.QuietHoursEnabled = func() bool { return m.QuietHoursEnabled }
	o.QuietHoursStart = func() null.Val[string] { return m.QuietHoursStart }
	o.QuietHoursEnd = func() null.Val[string] { return m.QuietHoursEnd }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.User != nil {
		UserPreferenceMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewUser(mods ...UserMod) *UserTemplate {
	return f.NewUserWithContext(context.Background(), mods...)
}

func (f *Factory) NewUserWithContext(ctx context.Context, mods ...UserMod) *UserTemplate {
	o := &UserTemplate{f: f}

	if f != nil {
		f.baseUserMods.Apply(ctx, o)
	}

	UserModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingUser(m *models.User) *UserTemplate {
	o := &UserTemplate{f: f, alreadyPersisted: true}

	o.ID = func() uuid.UUID { return m.ID }
	o.Auth0Sub = func() string { return m.Auth0Sub }
	o.DisplayName = func() string { return m.DisplayName }
	o.Avatar = func() null.Val[string] { return m.Avatar }
	o.Bio = func() null.Val[string] { return m.Bio }
	o.PhoneNumber = func() null.Val[string] { return m.PhoneNumber }
	o.Timezone = func() string { return m.Timezone }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.AvailabilityAutoRules) > 0 {
		UserMods.AddExistingAvailabilityAutoRules(m.R.AvailabilityAutoRules...).Apply(ctx, o)
	}
	if len(m.R.AvailabilityWindows) > 0 {
		UserMods.AddExistingAvailabilityWindows(m.R.AvailabilityWindows...).Apply(ctx, o)
	}
	if len(m.R.CheckIns) > 0 {
		UserMods.AddExistingCheckIns(m.R.CheckIns...).Apply(ctx, o)
	}
	if len(m.R.InviteeCircleInvitations) > 0 {
		UserMods.AddExistingInviteeCircleInvitations(m.R.InviteeCircleInvitations...).Apply(ctx, o)
	}
	if len(m.R.InviterCircleInvitations) > 0 {
		UserMods.AddExistingInviterCircleInvitations(m.R.InviterCircleInvitations...).Apply(ctx, o)
	}
	if len(m.R.CircleMembers) > 0 {
		UserMods.AddExistingCircleMembers(m.R.CircleMembers...).Apply(ctx, o)
	}
	if len(m.R.CircleSharingPreferences) > 0 {
		UserMods.AddExistingCircleSharingPreferences(m.R.CircleSharingPreferences...).Apply(ctx, o)
	}
	if len(m.R.CreatedByCircles) > 0 {
		UserMods.AddExistingCreatedByCircles(m.R.CreatedByCircles...).Apply(ctx, o)
	}
	if len(m.R.FromUserContactRequests) > 0 {
		UserMods.AddExistingFromUserContactRequests(m.R.FromUserContactRequests...).Apply(ctx, o)
	}
	if len(m.R.ToUserContactRequests) > 0 {
		UserMods.AddExistingToUserContactRequests(m.R.ToUserContactRequests...).Apply(ctx, o)
	}
	if len(m.R.ContactContacts) > 0 {
		UserMods.AddExistingContactContacts(m.R.ContactContacts...).Apply(ctx, o)
	}
	if len(m.R.Contacts) > 0 {
		UserMods.AddExistingContacts(m.R.Contacts...).Apply(ctx, o)
	}
	if len(m.R.ConversationParticipants) > 0 {
		UserMods.AddExistingConversationParticipants(m.R.ConversationParticipants...).Apply(ctx, o)
	}
	if len(m.R.LocationHistories) > 0 {
		UserMods.AddExistingLocationHistories(m.R.LocationHistories...).Apply(ctx, o)
	}
	if len(m.R.Media) > 0 {
		UserMods.AddExistingMedia(m.R.Media...).Apply(ctx, o)
	}
	if len(m.R.MessageDeletions) > 0 {
		UserMods.AddExistingMessageDeletions(m.R.MessageDeletions...).Apply(ctx, o)
	}
	if len(m.R.MessageReactions) > 0 {
		UserMods.AddExistingMessageReactions(m.R.MessageReactions...).Apply(ctx, o)
	}
	if len(m.R.MessageReceipts) > 0 {
		UserMods.AddExistingMessageReceipts(m.R.MessageReceipts...).Apply(ctx, o)
	}
	if len(m.R.SenderMessages) > 0 {
		UserMods.AddExistingSenderMessages(m.R.SenderMessages...).Apply(ctx, o)
	}
	if len(m.R.Places) > 0 {
		UserMods.AddExistingPlaces(m.R.Places...).Apply(ctx, o)
	}
	if m.R.UserAvailability != nil {
		UserMods.WithExistingUserAvailability(m.R.UserAvailability).Apply(ctx, o)
	}
	if m.R.UserLocation != nil {
		UserMods.WithExistingUserLocation(m.R.UserLocation).Apply(ctx, o)
	}
	if m.R.UserPreference != nil {
		UserMods.WithExistingUserPreference(m.R.UserPreference).Apply(ctx, o)
	}

	return o
}

func (f *Factory) ClearBaseAvailabilityAutoRuleMods() {
	f.baseAvailabilityAutoRuleMods = nil
}

func (f *Factory) AddBaseAvailabilityAutoRuleMod(mods ...AvailabilityAutoRuleMod) {
	f.baseAvailabilityAutoRuleMods = append(f.baseAvailabilityAutoRuleMods, mods...)
}

func (f *Factory) ClearBaseAvailabilityWindowMods() {
	f.baseAvailabilityWindowMods = nil
}

func (f *Factory) AddBaseAvailabilityWindowMod(mods ...AvailabilityWindowMod) {
	f.baseAvailabilityWindowMods = append(f.baseAvailabilityWindowMods, mods...)
}

func (f *Factory) ClearBaseCheckInMods() {
	f.baseCheckInMods = nil
}

func (f *Factory) AddBaseCheckInMod(mods ...CheckInMod) {
	f.baseCheckInMods = append(f.baseCheckInMods, mods...)
}

func (f *Factory) ClearBaseCircleInvitationMods() {
	f.baseCircleInvitationMods = nil
}

func (f *Factory) AddBaseCircleInvitationMod(mods ...CircleInvitationMod) {
	f.baseCircleInvitationMods = append(f.baseCircleInvitationMods, mods...)
}

func (f *Factory) ClearBaseCircleMemberMods() {
	f.baseCircleMemberMods = nil
}

func (f *Factory) AddBaseCircleMemberMod(mods ...CircleMemberMod) {
	f.baseCircleMemberMods = append(f.baseCircleMemberMods, mods...)
}

func (f *Factory) ClearBaseCircleSharingPreferenceMods() {
	f.baseCircleSharingPreferenceMods = nil
}

func (f *Factory) AddBaseCircleSharingPreferenceMod(mods ...CircleSharingPreferenceMod) {
	f.baseCircleSharingPreferenceMods = append(f.baseCircleSharingPreferenceMods, mods...)
}

func (f *Factory) ClearBaseCircleMods() {
	f.baseCircleMods = nil
}

func (f *Factory) AddBaseCircleMod(mods ...CircleMod) {
	f.baseCircleMods = append(f.baseCircleMods, mods...)
}

func (f *Factory) ClearBaseContactRequestMods() {
	f.baseContactRequestMods = nil
}

func (f *Factory) AddBaseContactRequestMod(mods ...ContactRequestMod) {
	f.baseContactRequestMods = append(f.baseContactRequestMods, mods...)
}

func (f *Factory) ClearBaseContactMods() {
	f.baseContactMods = nil
}

func (f *Factory) AddBaseContactMod(mods ...ContactMod) {
	f.baseContactMods = append(f.baseContactMods, mods...)
}

func (f *Factory) ClearBaseConversationParticipantMods() {
	f.baseConversationParticipantMods = nil
}

func (f *Factory) AddBaseConversationParticipantMod(mods ...ConversationParticipantMod) {
	f.baseConversationParticipantMods = append(f.baseConversationParticipantMods, mods...)
}

func (f *Factory) ClearBaseConversationMods() {
	f.baseConversationMods = nil
}

func (f *Factory) AddBaseConversationMod(mods ...ConversationMod) {
	f.baseConversationMods = append(f.baseConversationMods, mods...)
}

func (f *Factory) ClearBaseLocationHistoryMods() {
	f.baseLocationHistoryMods = nil
}

func (f *Factory) AddBaseLocationHistoryMod(mods ...LocationHistoryMod) {
	f.baseLocationHistoryMods = append(f.baseLocationHistoryMods, mods...)
}

func (f *Factory) ClearBaseMediumMods() {
	f.baseMediumMods = nil
}

func (f *Factory) AddBaseMediumMod(mods ...MediumMod) {
	f.baseMediumMods = append(f.baseMediumMods, mods...)
}

func (f *Factory) ClearBaseMessageDeletionMods() {
	f.baseMessageDeletionMods = nil
}

func (f *Factory) AddBaseMessageDeletionMod(mods ...MessageDeletionMod) {
	f.baseMessageDeletionMods = append(f.baseMessageDeletionMods, mods...)
}

func (f *Factory) ClearBaseMessageReactionMods() {
	f.baseMessageReactionMods = nil
}

func (f *Factory) AddBaseMessageReactionMod(mods ...MessageReactionMod) {
	f.baseMessageReactionMods = append(f.baseMessageReactionMods, mods...)
}

func (f *Factory) ClearBaseMessageReceiptMods() {
	f.baseMessageReceiptMods = nil
}

func (f *Factory) AddBaseMessageReceiptMod(mods ...MessageReceiptMod) {
	f.baseMessageReceiptMods = append(f.baseMessageReceiptMods, mods...)
}

func (f *Factory) ClearBaseMessageMods() {
	f.baseMessageMods = nil
}

func (f *Factory) AddBaseMessageMod(mods ...MessageMod) {
	f.baseMessageMods = append(f.baseMessageMods, mods...)
}

func (f *Factory) ClearBasePlaceMods() {
	f.basePlaceMods = nil
}

func (f *Factory) AddBasePlaceMod(mods ...PlaceMod) {
	f.basePlaceMods = append(f.basePlaceMods, mods...)
}

func (f *Factory) ClearBaseUserAvailabilityMods() {
	f.baseUserAvailabilityMods = nil
}

func (f *Factory) AddBaseUserAvailabilityMod(mods ...UserAvailabilityMod) {
	f.baseUserAvailabilityMods = append(f.baseUserAvailabilityMods, mods...)
}

func (f *Factory) ClearBaseUserLocationMods() {
	f.baseUserLocationMods = nil
}

func (f *Factory) AddBaseUserLocationMod(mods ...UserLocationMod) {
	f.baseUserLocationMods = append(f.baseUserLocationMods, mods...)
}

func (f *Factory) ClearBaseUserPreferenceMods() {
	f.baseUserPreferenceMods = nil
}

func (f *Factory) AddBaseUserPreferenceMod(mods ...UserPreferenceMod) {
	f.baseUserPreferenceMods = append(f.baseUserPreferenceMods, mods...)
}

func (f *Factory) ClearBaseUserMods() {
	f.baseUserMods = nil
}

func (f *Factory) AddBaseUserMod(mods ...UserMod) {
	f.baseUserMods = append(f.baseUserMods, mods...)
}
