// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/orm"
)

var Preload = getPreloaders()

type preloaders struct {
	AvailabilityAutoRule    availabilityAutoRulePreloader
	AvailabilityWindow      availabilityWindowPreloader
	CheckIn                 checkInPreloader
	CircleInvitation        circleInvitationPreloader
	CircleMember            circleMemberPreloader
	CircleSharingPreference circleSharingPreferencePreloader
	Circle                  circlePreloader
	ContactRequest          contactRequestPreloader
	Contact                 contactPreloader
	ConversationParticipant conversationParticipantPreloader
	Conversation            conversationPreloader
	LocationHistory         locationHistoryPreloader
	Medium                  mediumPreloader
	MessageDeletion         messageDeletionPreloader
	MessageReaction         messageReactionPreloader
	MessageReceipt          messageReceiptPreloader
	Message                 messagePreloader
	Place                   placePreloader
	UserAvailability        userAvailabilityPreloader
	UserLocation            userLocationPreloader
	UserPreference          userPreferencePreloader
	User                    userPreloader
}

func getPreloaders() preloaders {
	return preloaders{
		AvailabilityAutoRule:    buildAvailabilityAutoRulePreloader(),
		AvailabilityWindow:      buildAvailabilityWindowPreloader(),
		CheckIn:                 buildCheckInPreloader(),
		CircleInvitation:        buildCircleInvitationPreloader(),
		CircleMember:            buildCircleMemberPreloader(),
		CircleSharingPreference: buildCircleSharingPreferencePreloader(),
		Circle:                  buildCirclePreloader(),
		ContactRequest:          buildContactRequestPreloader(),
		Contact:                 buildContactPreloader(),
		ConversationParticipant: buildConversationParticipantPreloader(),
		Conversation:            buildConversationPreloader(),
		LocationHistory:         buildLocationHistoryPreloader(),
		Medium:                  buildMediumPreloader(),
		MessageDeletion:         buildMessageDeletionPreloader(),
		MessageReaction:         buildMessageReactionPreloader(),
		MessageReceipt:          buildMessageReceiptPreloader(),
		Message:                 buildMessagePreloader(),
		Place:                   buildPlacePreloader(),
		UserAvailability:        buildUserAvailabilityPreloader(),
		UserLocation:            buildUserLocationPreloader(),
		UserPreference:          buildUserPreferencePreloader(),
		User:                    buildUserPreloader(),
	}
}

var (
	SelectThenLoad = getThenLoaders[*dialect.SelectQuery]()
	InsertThenLoad = getThenLoaders[*dialect.InsertQuery]()
	UpdateThenLoad = getThenLoaders[*dialect.UpdateQuery]()
)

type thenLoaders[Q orm.Loadable] struct {
	AvailabilityAutoRule    availabilityAutoRuleThenLoader[Q]
	AvailabilityWindow      availabilityWindowThenLoader[Q]
	CheckIn                 checkInThenLoader[Q]
	CircleInvitation        circleInvitationThenLoader[Q]
	CircleMember            circleMemberThenLoader[Q]
	CircleSharingPreference circleSharingPreferenceThenLoader[Q]
	Circle                  circleThenLoader[Q]
	ContactRequest          contactRequestThenLoader[Q]
	Contact                 contactThenLoader[Q]
	ConversationParticipant conversationParticipantThenLoader[Q]
	Conversation            conversationThenLoader[Q]
	LocationHistory         locationHistoryThenLoader[Q]
	Medium                  mediumThenLoader[Q]
	MessageDeletion         messageDeletionThenLoader[Q]
	MessageReaction         messageReactionThenLoader[Q]
	MessageReceipt          messageReceiptThenLoader[Q]
	Message                 messageThenLoader[Q]
	Place                   placeThenLoader[Q]
	UserAvailability        userAvailabilityThenLoader[Q]
	UserLocation            userLocationThenLoader[Q]
	UserPreference          userPreferenceThenLoader[Q]
	User                    userThenLoader[Q]
}

func getThenLoaders[Q orm.Loadable]() thenLoaders[Q] {
	return thenLoaders[Q]{
		AvailabilityAutoRule:    buildAvailabilityAutoRuleThenLoader[Q](),
		AvailabilityWindow:      buildAvailabilityWindowThenLoader[Q](),
		CheckIn:                 buildCheckInThenLoader[Q](),
		CircleInvitation:        buildCircleInvitationThenLoader[Q](),
		CircleMember:            buildCircleMemberThenLoader[Q](),
		CircleSharingPreference: buildCircleSharingPreferenceThenLoader[Q](),
		Circle:                  buildCircleThenLoader[Q](),
		ContactRequest:          buildContactRequestThenLoader[Q](),
		Contact:                 buildContactThenLoader[Q](),
		ConversationParticipant: buildConversationParticipantThenLoader[Q](),
		Conversation:            buildConversationThenLoader[Q](),
		LocationHistory:         buildLocationHistoryThenLoader[Q](),
		Medium:                  buildMediumThenLoader[Q](),
		MessageDeletion:         buildMessageDeletionThenLoader[Q](),
		MessageReaction:         buildMessageReactionThenLoader[Q](),
		MessageReceipt:          buildMessageReceiptThenLoader[Q](),
		Message:                 buildMessageThenLoader[Q](),
		Place:                   buildPlaceThenLoader[Q](),
		UserAvailability:        buildUserAvailabilityThenLoader[Q](),
		UserLocation:            buildUserLocationThenLoader[Q](),
		UserPreference:          buildUserPreferenceThenLoader[Q](),
		User:                    buildUserThenLoader[Q](),
	}
}

func thenLoadBuilder[Q orm.Loadable, T any](name string, f func(context.Context, bob.Executor, T, ...bob.Mod[*dialect.SelectQuery]) error) func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
	return func(queryMods ...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q] {
		return func(ctx context.Context, exec bob.Executor, retrieved any) error {
			loader, isLoader := retrieved.(T)
			if !isLoader {
				return fmt.Errorf("object %T cannot load %q", retrieved, name)
			}

			err := f(ctx, exec, loader, queryMods...)

			// Don't cause an issue due to missing relationships
			if errors.Is(err, sql.ErrNoRows) {
				return nil
			}

			return err
		}
	}
}
