// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// User is an object representing the database table.
type User struct {
	ID          uuid.UUID        `db:"id,pk" `
	Auth0Sub    string           `db:"auth0_sub" `
	DisplayName string           `db:"display_name" `
	Avatar      null.Val[string] `db:"avatar" `
	Bio         null.Val[string] `db:"bio" `
	PhoneNumber null.Val[string] `db:"phone_number" `
	Timezone    string           `db:"timezone" `
	CreatedAt   time.Time        `db:"created_at" `
	UpdatedAt   time.Time        `db:"updated_at" `

	R userR `db:"-" `
}

// UserSlice is an alias for a slice of pointers to User.
// This should almost always be used instead of []*User.
type UserSlice []*User

// Users contains methods to work with the users table
var Users = psql.NewTablex[*User, UserSlice, *UserSetter]("", "users", buildUserColumns("users"))

// UsersQuery is a query on the users table
type UsersQuery = *psql.ViewQuery[*User, UserSlice]

// userR is where relationships are stored.
type userR struct {
	AvailabilityAutoRules    AvailabilityAutoRuleSlice    // availability_auto_rules.fk_availability_auto_rules_user_id
	AvailabilityWindows      AvailabilityWindowSlice      // availability_windows.fk_availability_windows_user_id
	CheckIns                 CheckInSlice                 // check_ins.fk_check_ins_user_id
	InviteeCircleInvitations CircleInvitationSlice        // circle_invitations.fk_circle_invitations_invitee_id
	InviterCircleInvitations CircleInvitationSlice        // circle_invitations.fk_circle_invitations_inviter_id
	CircleMembers            CircleMemberSlice            // circle_members.fk_circle_members_user_id
	CircleSharingPreferences CircleSharingPreferenceSlice // circle_sharing_preferences.fk_circle_sharing_preferences_user_id
	CreatedByCircles         CircleSlice                  // circles.fk_circles_created_by
	FromUserContactRequests  ContactRequestSlice          // contact_requests.fk_contact_requests_from_user_id
	ToUserContactRequests    ContactRequestSlice          // contact_requests.fk_contact_requests_to_user_id
	ContactContacts          ContactSlice                 // contacts.fk_contacts_contact_id
	Contacts                 ContactSlice                 // contacts.fk_contacts_user_id
	ConversationParticipants ConversationParticipantSlice // conversation_participants.fk_conversation_participants_user_id
	LocationHistories        LocationHistorySlice         // location_history.fk_location_history_user_id
	Media                    MediumSlice                  // media.fk_media_user_id
	MessageDeletions         MessageDeletionSlice         // message_deletions.fk_message_deletions_user_id
	MessageReactions         MessageReactionSlice         // message_reactions.fk_message_reactions_user_id
	MessageReceipts          MessageReceiptSlice          // message_receipts.fk_message_receipts_user_id
	SenderMessages           MessageSlice                 // messages.fk_messages_sender_id
	Places                   PlaceSlice                   // places.fk_places_user_id
	UserAvailability         *UserAvailability            // user_availability.fk_user_availability_user_id
	UserLocation             *UserLocation                // user_locations.fk_user_locations_user_id
	UserPreference           *UserPreference              // user_preferences.fk_user_preferences_user_id
}

func buildUserColumns(alias string) userColumns {
	return userColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "auth0_sub", "display_name", "avatar", "bio", "phone_number", "timezone", "created_at", "updated_at",
		).WithParent("users"),
		tableAlias:  alias,
		ID:          psql.Quote(alias, "id"),
		Auth0Sub:    psql.Quote(alias, "auth0_sub"),
		DisplayName: psql.Quote(alias, "display_name"),
		Avatar:      psql.Quote(alias, "avatar"),
		Bio:         psql.Quote(alias, "bio"),
		PhoneNumber: psql.Quote(alias, "phone_number"),
		Timezone:    psql.Quote(alias, "timezone"),
		CreatedAt:   psql.Quote(alias, "created_at"),
		UpdatedAt:   psql.Quote(alias, "updated_at"),
	}
}

type userColumns struct {
	expr.ColumnsExpr
	tableAlias  string
	ID          psql.Expression
	Auth0Sub    psql.Expression
	DisplayName psql.Expression
	Avatar      psql.Expression
	Bio         psql.Expression
	PhoneNumber psql.Expression
	Timezone    psql.Expression
	CreatedAt   psql.Expression
	UpdatedAt   psql.Expression
}

func (c userColumns) Alias() string {
	return c.tableAlias
}

func (userColumns) AliasedAs(alias string) userColumns {
	return buildUserColumns(alias)
}

// UserSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type UserSetter struct {
	ID          omit.Val[uuid.UUID]  `db:"id,pk" `
	Auth0Sub    omit.Val[string]     `db:"auth0_sub" `
	DisplayName omit.Val[string]     `db:"display_name" `
	Avatar      omitnull.Val[string] `db:"avatar" `
	Bio         omitnull.Val[string] `db:"bio" `
	PhoneNumber omitnull.Val[string] `db:"phone_number" `
	Timezone    omit.Val[string]     `db:"timezone" `
	CreatedAt   omit.Val[time.Time]  `db:"created_at" `
	UpdatedAt   omit.Val[time.Time]  `db:"updated_at" `
}

func (s UserSetter) SetColumns() []string {
	vals := make([]string, 0, 9)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.Auth0Sub.IsValue() {
		vals = append(vals, "auth0_sub")
	}
	if s.DisplayName.IsValue() {
		vals = append(vals, "display_name")
	}
	if !s.Avatar.IsUnset() {
		vals = append(vals, "avatar")
	}
	if !s.Bio.IsUnset() {
		vals = append(vals, "bio")
	}
	if !s.PhoneNumber.IsUnset() {
		vals = append(vals, "phone_number")
	}
	if s.Timezone.IsValue() {
		vals = append(vals, "timezone")
	}
	if s.CreatedAt.IsValue() {
		vals = append(vals, "created_at")
	}
	if s.UpdatedAt.IsValue() {
		vals = append(vals, "updated_at")
	}
	return vals
}

func (s UserSetter) Overwrite(t *User) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.Auth0Sub.IsValue() {
		t.Auth0Sub = s.Auth0Sub.MustGet()
	}
	if s.DisplayName.IsValue() {
		t.DisplayName = s.DisplayName.MustGet()
	}
	if !s.Avatar.IsUnset() {
		t.Avatar = s.Avatar.MustGetNull()
	}
	if !s.Bio.IsUnset() {
		t.Bio = s.Bio.MustGetNull()
	}
	if !s.PhoneNumber.IsUnset() {
		t.PhoneNumber = s.PhoneNumber.MustGetNull()
	}
	if s.Timezone.IsValue() {
		t.Timezone = s.Timezone.MustGet()
	}
	if s.CreatedAt.IsValue() {
		t.CreatedAt = s.CreatedAt.MustGet()
	}
	if s.UpdatedAt.IsValue() {
		t.UpdatedAt = s.UpdatedAt.MustGet()
	}
}

func (s *UserSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Users.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 9)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.Auth0Sub.IsValue() {
			vals[1] = psql.Arg(s.Auth0Sub.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.DisplayName.IsValue() {
			vals[2] = psql.Arg(s.DisplayName.MustGet())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if !s.Avatar.IsUnset() {
			vals[3] = psql.Arg(s.Avatar.MustGetNull())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.Bio.IsUnset() {
			vals[4] = psql.Arg(s.Bio.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.PhoneNumber.IsUnset() {
			vals[5] = psql.Arg(s.PhoneNumber.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if s.Timezone.IsValue() {
			vals[6] = psql.Arg(s.Timezone.MustGet())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt.IsValue() {
			vals[7] = psql.Arg(s.CreatedAt.MustGet())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if s.UpdatedAt.IsValue() {
			vals[8] = psql.Arg(s.UpdatedAt.MustGet())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s UserSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s UserSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 9)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.Auth0Sub.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "auth0_sub")...),
			psql.Arg(s.Auth0Sub),
		}})
	}

	if s.DisplayName.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "display_name")...),
			psql.Arg(s.DisplayName),
		}})
	}

	if !s.Avatar.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "avatar")...),
			psql.Arg(s.Avatar),
		}})
	}

	if !s.Bio.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "bio")...),
			psql.Arg(s.Bio),
		}})
	}

	if !s.PhoneNumber.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "phone_number")...),
			psql.Arg(s.PhoneNumber),
		}})
	}

	if s.Timezone.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "timezone")...),
			psql.Arg(s.Timezone),
		}})
	}

	if s.CreatedAt.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	if s.UpdatedAt.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "updated_at")...),
			psql.Arg(s.UpdatedAt),
		}})
	}

	return exprs
}

// FindUser retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindUser(ctx context.Context, exec bob.Executor, IDPK uuid.UUID, cols ...string) (*User, error) {
	if len(cols) == 0 {
		return Users.Query(
			sm.Where(Users.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return Users.Query(
		sm.Where(Users.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(Users.Columns.Only(cols...)),
	).One(ctx, exec)
}

// UserExists checks the presence of a single record by primary key
func UserExists(ctx context.Context, exec bob.Executor, IDPK uuid.UUID) (bool, error) {
	return Users.Query(
		sm.Where(Users.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after User is retrieved from the database
func (o *User) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Users.AfterSelectHooks.RunHooks(ctx, exec, UserSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Users.AfterInsertHooks.RunHooks(ctx, exec, UserSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Users.AfterUpdateHooks.RunHooks(ctx, exec, UserSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Users.AfterDeleteHooks.RunHooks(ctx, exec, UserSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the User
func (o *User) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *User) pkEQ() dialect.Expression {
	return psql.Quote("users", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the User
func (o *User) Update(ctx context.Context, exec bob.Executor, s *UserSetter) error {
	v, err := Users.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single User record with an executor
func (o *User) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Users.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the User using the executor
func (o *User) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Users.Query(
		sm.Where(Users.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after UserSlice is retrieved from the database
func (o UserSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Users.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Users.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Users.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Users.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o UserSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("users", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o UserSlice) copyMatchingRows(from ...*User) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o UserSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Users.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *User:
				o.copyMatchingRows(retrieved)
			case []*User:
				o.copyMatchingRows(retrieved...)
			case UserSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a User or a slice of User
				// then run the AfterUpdateHooks on the slice
				_, err = Users.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o UserSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Users.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *User:
				o.copyMatchingRows(retrieved)
			case []*User:
				o.copyMatchingRows(retrieved...)
			case UserSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a User or a slice of User
				// then run the AfterDeleteHooks on the slice
				_, err = Users.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o UserSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals UserSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Users.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o UserSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Users.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o UserSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Users.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// AvailabilityAutoRules starts a query for related objects on availability_auto_rules
func (o *User) AvailabilityAutoRules(mods ...bob.Mod[*dialect.SelectQuery]) AvailabilityAutoRulesQuery {
	return AvailabilityAutoRules.Query(append(mods,
		sm.Where(AvailabilityAutoRules.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) AvailabilityAutoRules(mods ...bob.Mod[*dialect.SelectQuery]) AvailabilityAutoRulesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return AvailabilityAutoRules.Query(append(mods,
		sm.Where(psql.Group(AvailabilityAutoRules.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// AvailabilityWindows starts a query for related objects on availability_windows
func (o *User) AvailabilityWindows(mods ...bob.Mod[*dialect.SelectQuery]) AvailabilityWindowsQuery {
	return AvailabilityWindows.Query(append(mods,
		sm.Where(AvailabilityWindows.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) AvailabilityWindows(mods ...bob.Mod[*dialect.SelectQuery]) AvailabilityWindowsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return AvailabilityWindows.Query(append(mods,
		sm.Where(psql.Group(AvailabilityWindows.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// CheckIns starts a query for related objects on check_ins
func (o *User) CheckIns(mods ...bob.Mod[*dialect.SelectQuery]) CheckInsQuery {
	return CheckIns.Query(append(mods,
		sm.Where(CheckIns.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) CheckIns(mods ...bob.Mod[*dialect.SelectQuery]) CheckInsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return CheckIns.Query(append(mods,
		sm.Where(psql.Group(CheckIns.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// InviteeCircleInvitations starts a query for related objects on circle_invitations
func (o *User) InviteeCircleInvitations(mods ...bob.Mod[*dialect.SelectQuery]) CircleInvitationsQuery {
	return CircleInvitations.Query(append(mods,
		sm.Where(CircleInvitations.Columns.InviteeID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) InviteeCircleInvitations(mods ...bob.Mod[*dialect.SelectQuery]) CircleInvitationsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return CircleInvitations.Query(append(mods,
		sm.Where(psql.Group(CircleInvitations.Columns.InviteeID).OP("IN", PKArgExpr)),
	)...)
}

// InviterCircleInvitations starts a query for related objects on circle_invitations
func (o *User) InviterCircleInvitations(mods ...bob.Mod[*dialect.SelectQuery]) CircleInvitationsQuery {
	return CircleInvitations.Query(append(mods,
		sm.Where(CircleInvitations.Columns.InviterID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) InviterCircleInvitations(mods ...bob.Mod[*dialect.SelectQuery]) CircleInvitationsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return CircleInvitations.Query(append(mods,
		sm.Where(psql.Group(CircleInvitations.Columns.InviterID).OP("IN", PKArgExpr)),
	)...)
}

// CircleMembers starts a query for related objects on circle_members
func (o *User) CircleMembers(mods ...bob.Mod[*dialect.SelectQuery]) CircleMembersQuery {
	return CircleMembers.Query(append(mods,
		sm.Where(CircleMembers.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) CircleMembers(mods ...bob.Mod[*dialect.SelectQuery]) CircleMembersQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return CircleMembers.Query(append(mods,
		sm.Where(psql.Group(CircleMembers.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// CircleSharingPreferences starts a query for related objects on circle_sharing_preferences
func (o *User) CircleSharingPreferences(mods ...bob.Mod[*dialect.SelectQuery]) CircleSharingPreferencesQuery {
	return CircleSharingPreferences.Query(append(mods,
		sm.Where(CircleSharingPreferences.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) CircleSharingPreferences(mods ...bob.Mod[*dialect.SelectQuery]) CircleSharingPreferencesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return CircleSharingPreferences.Query(append(mods,
		sm.Where(psql.Group(CircleSharingPreferences.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// CreatedByCircles starts a query for related objects on circles
func (o *User) CreatedByCircles(mods ...bob.Mod[*dialect.SelectQuery]) CirclesQuery {
	return Circles.Query(append(mods,
		sm.Where(Circles.Columns.CreatedBy.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) CreatedByCircles(mods ...bob.Mod[*dialect.SelectQuery]) CirclesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Circles.Query(append(mods,
		sm.Where(psql.Group(Circles.Columns.CreatedBy).OP("IN", PKArgExpr)),
	)...)
}

// FromUserContactRequests starts a query for related objects on contact_requests
func (o *User) FromUserContactRequests(mods ...bob.Mod[*dialect.SelectQuery]) ContactRequestsQuery {
	return ContactRequests.Query(append(mods,
		sm.Where(ContactRequests.Columns.FromUserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) FromUserContactRequests(mods ...bob.Mod[*dialect.SelectQuery]) ContactRequestsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return ContactRequests.Query(append(mods,
		sm.Where(psql.Group(ContactRequests.Columns.FromUserID).OP("IN", PKArgExpr)),
	)...)
}

// ToUserContactRequests starts a query for related objects on contact_requests
func (o *User) ToUserContactRequests(mods ...bob.Mod[*dialect.SelectQuery]) ContactRequestsQuery {
	return ContactRequests.Query(append(mods,
		sm.Where(ContactRequests.Columns.ToUserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) ToUserContactRequests(mods ...bob.Mod[*dialect.SelectQuery]) ContactRequestsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return ContactRequests.Query(append(mods,
		sm.Where(psql.Group(ContactRequests.Columns.ToUserID).OP("IN", PKArgExpr)),
	)...)
}

// ContactContacts starts a query for related objects on contacts
func (o *User) ContactContacts(mods ...bob.Mod[*dialect.SelectQuery]) ContactsQuery {
	return Contacts.Query(append(mods,
		sm.Where(Contacts.Columns.ContactID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) ContactContacts(mods ...bob.Mod[*dialect.SelectQuery]) ContactsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Contacts.Query(append(mods,
		sm.Where(psql.Group(Contacts.Columns.ContactID).OP("IN", PKArgExpr)),
	)...)
}

// Contacts starts a query for related objects on contacts
func (o *User) Contacts(mods ...bob.Mod[*dialect.SelectQuery]) ContactsQuery {
	return Contacts.Query(append(mods,
		sm.Where(Contacts.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) Contacts(mods ...bob.Mod[*dialect.SelectQuery]) ContactsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Contacts.Query(append(mods,
		sm.Where(psql.Group(Contacts.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// ConversationParticipants starts a query for related objects on conversation_participants
func (o *User) ConversationParticipants(mods ...bob.Mod[*dialect.SelectQuery]) ConversationParticipantsQuery {
	return ConversationParticipants.Query(append(mods,
		sm.Where(ConversationParticipants.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) ConversationParticipants(mods ...bob.Mod[*dialect.SelectQuery]) ConversationParticipantsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return ConversationParticipants.Query(append(mods,
		sm.Where(psql.Group(ConversationParticipants.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// LocationHistories starts a query for related objects on location_history
func (o *User) LocationHistories(mods ...bob.Mod[*dialect.SelectQuery]) LocationHistoriesQuery {
	return LocationHistories.Query(append(mods,
		sm.Where(LocationHistories.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) LocationHistories(mods ...bob.Mod[*dialect.SelectQuery]) LocationHistoriesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return LocationHistories.Query(append(mods,
		sm.Where(psql.Group(LocationHistories.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// Media starts a query for related objects on media
func (o *User) Media(mods ...bob.Mod[*dialect.SelectQuery]) MediaQuery {
	return Media.Query(append(mods,
		sm.Where(Media.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) Media(mods ...bob.Mod[*dialect.SelectQuery]) MediaQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Media.Query(append(mods,
		sm.Where(psql.Group(Media.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// MessageDeletions starts a query for related objects on message_deletions
func (o *User) MessageDeletions(mods ...bob.Mod[*dialect.SelectQuery]) MessageDeletionsQuery {
	return MessageDeletions.Query(append(mods,
		sm.Where(MessageDeletions.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) MessageDeletions(mods ...bob.Mod[*dialect.SelectQuery]) MessageDeletionsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return MessageDeletions.Query(append(mods,
		sm.Where(psql.Group(MessageDeletions.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// MessageReactions starts a query for related objects on message_reactions
func (o *User) MessageReactions(mods ...bob.Mod[*dialect.SelectQuery]) MessageReactionsQuery {
	return MessageReactions.Query(append(mods,
		sm.Where(MessageReactions.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) MessageReactions(mods ...bob.Mod[*dialect.SelectQuery]) MessageReactionsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return MessageReactions.Query(append(mods,
		sm.Where(psql.Group(MessageReactions.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// MessageReceipts starts a query for related objects on message_receipts
func (o *User) MessageReceipts(mods ...bob.Mod[*dialect.SelectQuery]) MessageReceiptsQuery {
	return MessageReceipts.Query(append(mods,
		sm.Where(MessageReceipts.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) MessageReceipts(mods ...bob.Mod[*dialect.SelectQuery]) MessageReceiptsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return MessageReceipts.Query(append(mods,
		sm.Where(psql.Group(MessageReceipts.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// SenderMessages starts a query for related objects on messages
func (o *User) SenderMessages(mods ...bob.Mod[*dialect.SelectQuery]) MessagesQuery {
	return Messages.Query(append(mods,
		sm.Where(Messages.Columns.SenderID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) SenderMessages(mods ...bob.Mod[*dialect.SelectQuery]) MessagesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Messages.Query(append(mods,
		sm.Where(psql.Group(Messages.Columns.SenderID).OP("IN", PKArgExpr)),
	)...)
}

// Places starts a query for related objects on places
func (o *User) Places(mods ...bob.Mod[*dialect.SelectQuery]) PlacesQuery {
	return Places.Query(append(mods,
		sm.Where(Places.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) Places(mods ...bob.Mod[*dialect.SelectQuery]) PlacesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return Places.Query(append(mods,
		sm.Where(psql.Group(Places.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// UserAvailability starts a query for related objects on user_availability
func (o *User) UserAvailability(mods ...bob.Mod[*dialect.SelectQuery]) UserAvailabilitiesQuery {
	return UserAvailabilities.Query(append(mods,
		sm.Where(UserAvailabilities.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) UserAvailability(mods ...bob.Mod[*dialect.SelectQuery]) UserAvailabilitiesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return UserAvailabilities.Query(append(mods,
		sm.Where(psql.Group(UserAvailabilities.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// UserLocation starts a query for related objects on user_locations
func (o *User) UserLocation(mods ...bob.Mod[*dialect.SelectQuery]) UserLocationsQuery {
	return UserLocations.Query(append(mods,
		sm.Where(UserLocations.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) UserLocation(mods ...bob.Mod[*dialect.SelectQuery]) UserLocationsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return UserLocations.Query(append(mods,
		sm.Where(psql.Group(UserLocations.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

// UserPreference starts a query for related objects on user_preferences
func (o *User) UserPreference(mods ...bob.Mod[*dialect.SelectQuery]) UserPreferencesQuery {
	return UserPreferences.Query(append(mods,
		sm.Where(UserPreferences.Columns.UserID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os UserSlice) UserPreference(mods ...bob.Mod[*dialect.SelectQuery]) UserPreferencesQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return UserPreferences.Query(append(mods,
		sm.Where(psql.Group(UserPreferences.Columns.UserID).OP("IN", PKArgExpr)),
	)...)
}

func insertUserAvailabilityAutoRules0(ctx context.Context, exec bob.Executor, availabilityAutoRules1 []*AvailabilityAutoRuleSetter, user0 *User) (AvailabilityAutoRuleSlice, error) {
	for i := range availabilityAutoRules1 {
		availabilityAutoRules1[i].UserID = omit.From(user0.ID)
	}

	ret, err := AvailabilityAutoRules.Insert(bob.ToMods(availabilityAutoRules1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserAvailabilityAutoRules0: %w", err)
	}

	return ret, nil
}

func attachUserAvailabilityAutoRules0(ctx context.Context, exec bob.Executor, count int, availabilityAutoRules1 AvailabilityAutoRuleSlice, user0 *User) (AvailabilityAutoRuleSlice, error) {
	setter := &AvailabilityAutoRuleSetter{
		UserID: omit.From(user0.ID),
	}

	err := availabilityAutoRules1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserAvailabilityAutoRules0: %w", err)
	}

	return availabilityAutoRules1, nil
}

func (user0 *User) InsertAvailabilityAutoRules(ctx context.Context, exec bob.Executor, related ...*AvailabilityAutoRuleSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	availabilityAutoRules1, err := insertUserAvailabilityAutoRules0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.AvailabilityAutoRules = append(user0.R.AvailabilityAutoRules, availabilityAutoRules1...)

	for _, rel := range availabilityAutoRules1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachAvailabilityAutoRules(ctx context.Context, exec bob.Executor, related ...*AvailabilityAutoRule) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	availabilityAutoRules1 := AvailabilityAutoRuleSlice(related)

	_, err = attachUserAvailabilityAutoRules0(ctx, exec, len(related), availabilityAutoRules1, user0)
	if err != nil {
		return err
	}

	user0.R.AvailabilityAutoRules = append(user0.R.AvailabilityAutoRules, availabilityAutoRules1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserAvailabilityWindows0(ctx context.Context, exec bob.Executor, availabilityWindows1 []*AvailabilityWindowSetter, user0 *User) (AvailabilityWindowSlice, error) {
	for i := range availabilityWindows1 {
		availabilityWindows1[i].UserID = omit.From(user0.ID)
	}

	ret, err := AvailabilityWindows.Insert(bob.ToMods(availabilityWindows1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserAvailabilityWindows0: %w", err)
	}

	return ret, nil
}

func attachUserAvailabilityWindows0(ctx context.Context, exec bob.Executor, count int, availabilityWindows1 AvailabilityWindowSlice, user0 *User) (AvailabilityWindowSlice, error) {
	setter := &AvailabilityWindowSetter{
		UserID: omit.From(user0.ID),
	}

	err := availabilityWindows1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserAvailabilityWindows0: %w", err)
	}

	return availabilityWindows1, nil
}

func (user0 *User) InsertAvailabilityWindows(ctx context.Context, exec bob.Executor, related ...*AvailabilityWindowSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	availabilityWindows1, err := insertUserAvailabilityWindows0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.AvailabilityWindows = append(user0.R.AvailabilityWindows, availabilityWindows1...)

	for _, rel := range availabilityWindows1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachAvailabilityWindows(ctx context.Context, exec bob.Executor, related ...*AvailabilityWindow) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	availabilityWindows1 := AvailabilityWindowSlice(related)

	_, err = attachUserAvailabilityWindows0(ctx, exec, len(related), availabilityWindows1, user0)
	if err != nil {
		return err
	}

	user0.R.AvailabilityWindows = append(user0.R.AvailabilityWindows, availabilityWindows1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserCheckIns0(ctx context.Context, exec bob.Executor, checkIns1 []*CheckInSetter, user0 *User) (CheckInSlice, error) {
	for i := range checkIns1 {
		checkIns1[i].UserID = omit.From(user0.ID)
	}

	ret, err := CheckIns.Insert(bob.ToMods(checkIns1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserCheckIns0: %w", err)
	}

	return ret, nil
}

func attachUserCheckIns0(ctx context.Context, exec bob.Executor, count int, checkIns1 CheckInSlice, user0 *User) (CheckInSlice, error) {
	setter := &CheckInSetter{
		UserID: omit.From(user0.ID),
	}

	err := checkIns1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserCheckIns0: %w", err)
	}

	return checkIns1, nil
}

func (user0 *User) InsertCheckIns(ctx context.Context, exec bob.Executor, related ...*CheckInSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	checkIns1, err := insertUserCheckIns0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CheckIns = append(user0.R.CheckIns, checkIns1...)

	for _, rel := range checkIns1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachCheckIns(ctx context.Context, exec bob.Executor, related ...*CheckIn) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	checkIns1 := CheckInSlice(related)

	_, err = attachUserCheckIns0(ctx, exec, len(related), checkIns1, user0)
	if err != nil {
		return err
	}

	user0.R.CheckIns = append(user0.R.CheckIns, checkIns1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserInviteeCircleInvitations0(ctx context.Context, exec bob.Executor, circleInvitations1 []*CircleInvitationSetter, user0 *User) (CircleInvitationSlice, error) {
	for i := range circleInvitations1 {
		circleInvitations1[i].InviteeID = omitnull.From(user0.ID)
	}

	ret, err := CircleInvitations.Insert(bob.ToMods(circleInvitations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserInviteeCircleInvitations0: %w", err)
	}

	return ret, nil
}

func attachUserInviteeCircleInvitations0(ctx context.Context, exec bob.Executor, count int, circleInvitations1 CircleInvitationSlice, user0 *User) (CircleInvitationSlice, error) {
	setter := &CircleInvitationSetter{
		InviteeID: omitnull.From(user0.ID),
	}

	err := circleInvitations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserInviteeCircleInvitations0: %w", err)
	}

	return circleInvitations1, nil
}

func (user0 *User) InsertInviteeCircleInvitations(ctx context.Context, exec bob.Executor, related ...*CircleInvitationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	circleInvitations1, err := insertUserInviteeCircleInvitations0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.InviteeCircleInvitations = append(user0.R.InviteeCircleInvitations, circleInvitations1...)

	for _, rel := range circleInvitations1 {
		rel.R.InviteeUser = user0
	}
	return nil
}

func (user0 *User) AttachInviteeCircleInvitations(ctx context.Context, exec bob.Executor, related ...*CircleInvitation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	circleInvitations1 := CircleInvitationSlice(related)

	_, err = attachUserInviteeCircleInvitations0(ctx, exec, len(related), circleInvitations1, user0)
	if err != nil {
		return err
	}

	user0.R.InviteeCircleInvitations = append(user0.R.InviteeCircleInvitations, circleInvitations1...)

	for _, rel := range related {
		rel.R.InviteeUser = user0
	}

	return nil
}

func insertUserInviterCircleInvitations0(ctx context.Context, exec bob.Executor, circleInvitations1 []*CircleInvitationSetter, user0 *User) (CircleInvitationSlice, error) {
	for i := range circleInvitations1 {
		circleInvitations1[i].InviterID = omit.From(user0.ID)
	}

	ret, err := CircleInvitations.Insert(bob.ToMods(circleInvitations1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserInviterCircleInvitations0: %w", err)
	}

	return ret, nil
}

func attachUserInviterCircleInvitations0(ctx context.Context, exec bob.Executor, count int, circleInvitations1 CircleInvitationSlice, user0 *User) (CircleInvitationSlice, error) {
	setter := &CircleInvitationSetter{
		InviterID: omit.From(user0.ID),
	}

	err := circleInvitations1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserInviterCircleInvitations0: %w", err)
	}

	return circleInvitations1, nil
}

func (user0 *User) InsertInviterCircleInvitations(ctx context.Context, exec bob.Executor, related ...*CircleInvitationSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	circleInvitations1, err := insertUserInviterCircleInvitations0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.InviterCircleInvitations = append(user0.R.InviterCircleInvitations, circleInvitations1...)

	for _, rel := range circleInvitations1 {
		rel.R.InviterUser = user0
	}
	return nil
}

func (user0 *User) AttachInviterCircleInvitations(ctx context.Context, exec bob.Executor, related ...*CircleInvitation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	circleInvitations1 := CircleInvitationSlice(related)

	_, err = attachUserInviterCircleInvitations0(ctx, exec, len(related), circleInvitations1, user0)
	if err != nil {
		return err
	}

	user0.R.InviterCircleInvitations = append(user0.R.InviterCircleInvitations, circleInvitations1...)

	for _, rel := range related {
		rel.R.InviterUser = user0
	}

	return nil
}

func insertUserCircleMembers0(ctx context.Context, exec bob.Executor, circleMembers1 []*CircleMemberSetter, user0 *User) (CircleMemberSlice, error) {
	for i := range circleMembers1 {
		circleMembers1[i].UserID = omit.From(user0.ID)
	}

	ret, err := CircleMembers.Insert(bob.ToMods(circleMembers1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserCircleMembers0: %w", err)
	}

	return ret, nil
}

func attachUserCircleMembers0(ctx context.Context, exec bob.Executor, count int, circleMembers1 CircleMemberSlice, user0 *User) (CircleMemberSlice, error) {
	setter := &CircleMemberSetter{
		UserID: omit.From(user0.ID),
	}

	err := circleMembers1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserCircleMembers0: %w", err)
	}

	return circleMembers1, nil
}

func (user0 *User) InsertCircleMembers(ctx context.Context, exec bob.Executor, related ...*CircleMemberSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	circleMembers1, err := insertUserCircleMembers0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CircleMembers = append(user0.R.CircleMembers, circleMembers1...)

	for _, rel := range circleMembers1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachCircleMembers(ctx context.Context, exec bob.Executor, related ...*CircleMember) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	circleMembers1 := CircleMemberSlice(related)

	_, err = attachUserCircleMembers0(ctx, exec, len(related), circleMembers1, user0)
	if err != nil {
		return err
	}

	user0.R.CircleMembers = append(user0.R.CircleMembers, circleMembers1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserCircleSharingPreferences0(ctx context.Context, exec bob.Executor, circleSharingPreferences1 []*CircleSharingPreferenceSetter, user0 *User) (CircleSharingPreferenceSlice, error) {
	for i := range circleSharingPreferences1 {
		circleSharingPreferences1[i].UserID = omit.From(user0.ID)
	}

	ret, err := CircleSharingPreferences.Insert(bob.ToMods(circleSharingPreferences1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserCircleSharingPreferences0: %w", err)
	}

	return ret, nil
}

func attachUserCircleSharingPreferences0(ctx context.Context, exec bob.Executor, count int, circleSharingPreferences1 CircleSharingPreferenceSlice, user0 *User) (CircleSharingPreferenceSlice, error) {
	setter := &CircleSharingPreferenceSetter{
		UserID: omit.From(user0.ID),
	}

	err := circleSharingPreferences1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserCircleSharingPreferences0: %w", err)
	}

	return circleSharingPreferences1, nil
}

func (user0 *User) InsertCircleSharingPreferences(ctx context.Context, exec bob.Executor, related ...*CircleSharingPreferenceSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	circleSharingPreferences1, err := insertUserCircleSharingPreferences0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CircleSharingPreferences = append(user0.R.CircleSharingPreferences, circleSharingPreferences1...)

	for _, rel := range circleSharingPreferences1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachCircleSharingPreferences(ctx context.Context, exec bob.Executor, related ...*CircleSharingPreference) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	circleSharingPreferences1 := CircleSharingPreferenceSlice(related)

	_, err = attachUserCircleSharingPreferences0(ctx, exec, len(related), circleSharingPreferences1, user0)
	if err != nil {
		return err
	}

	user0.R.CircleSharingPreferences = append(user0.R.CircleSharingPreferences, circleSharingPreferences1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserCreatedByCircles0(ctx context.Context, exec bob.Executor, circles1 []*CircleSetter, user0 *User) (CircleSlice, error) {
	for i := range circles1 {
		circles1[i].CreatedBy = omit.From(user0.ID)
	}

	ret, err := Circles.Insert(bob.ToMods(circles1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserCreatedByCircles0: %w", err)
	}

	return ret, nil
}

func attachUserCreatedByCircles0(ctx context.Context, exec bob.Executor, count int, circles1 CircleSlice, user0 *User) (CircleSlice, error) {
	setter := &CircleSetter{
		CreatedBy: omit.From(user0.ID),
	}

	err := circles1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserCreatedByCircles0: %w", err)
	}

	return circles1, nil
}

func (user0 *User) InsertCreatedByCircles(ctx context.Context, exec bob.Executor, related ...*CircleSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	circles1, err := insertUserCreatedByCircles0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByCircles = append(user0.R.CreatedByCircles, circles1...)

	for _, rel := range circles1 {
		rel.R.CreatedByUser = user0
	}
	return nil
}

func (user0 *User) AttachCreatedByCircles(ctx context.Context, exec bob.Executor, related ...*Circle) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	circles1 := CircleSlice(related)

	_, err = attachUserCreatedByCircles0(ctx, exec, len(related), circles1, user0)
	if err != nil {
		return err
	}

	user0.R.CreatedByCircles = append(user0.R.CreatedByCircles, circles1...)

	for _, rel := range related {
		rel.R.CreatedByUser = user0
	}

	return nil
}

func insertUserFromUserContactRequests0(ctx context.Context, exec bob.Executor, contactRequests1 []*ContactRequestSetter, user0 *User) (ContactRequestSlice, error) {
	for i := range contactRequests1 {
		contactRequests1[i].FromUserID = omit.From(user0.ID)
	}

	ret, err := ContactRequests.Insert(bob.ToMods(contactRequests1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserFromUserContactRequests0: %w", err)
	}

	return ret, nil
}

func attachUserFromUserContactRequests0(ctx context.Context, exec bob.Executor, count int, contactRequests1 ContactRequestSlice, user0 *User) (ContactRequestSlice, error) {
	setter := &ContactRequestSetter{
		FromUserID: omit.From(user0.ID),
	}

	err := contactRequests1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserFromUserContactRequests0: %w", err)
	}

	return contactRequests1, nil
}

func (user0 *User) InsertFromUserContactRequests(ctx context.Context, exec bob.Executor, related ...*ContactRequestSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	contactRequests1, err := insertUserFromUserContactRequests0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.FromUserContactRequests = append(user0.R.FromUserContactRequests, contactRequests1...)

	for _, rel := range contactRequests1 {
		rel.R.FromUserUser = user0
	}
	return nil
}

func (user0 *User) AttachFromUserContactRequests(ctx context.Context, exec bob.Executor, related ...*ContactRequest) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	contactRequests1 := ContactRequestSlice(related)

	_, err = attachUserFromUserContactRequests0(ctx, exec, len(related), contactRequests1, user0)
	if err != nil {
		return err
	}

	user0.R.FromUserContactRequests = append(user0.R.FromUserContactRequests, contactRequests1...)

	for _, rel := range related {
		rel.R.FromUserUser = user0
	}

	return nil
}

func insertUserToUserContactRequests0(ctx context.Context, exec bob.Executor, contactRequests1 []*ContactRequestSetter, user0 *User) (ContactRequestSlice, error) {
	for i := range contactRequests1 {
		contactRequests1[i].ToUserID = omit.From(user0.ID)
	}

	ret, err := ContactRequests.Insert(bob.ToMods(contactRequests1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserToUserContactRequests0: %w", err)
	}

	return ret, nil
}

func attachUserToUserContactRequests0(ctx context.Context, exec bob.Executor, count int, contactRequests1 ContactRequestSlice, user0 *User) (ContactRequestSlice, error) {
	setter := &ContactRequestSetter{
		ToUserID: omit.From(user0.ID),
	}

	err := contactRequests1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserToUserContactRequests0: %w", err)
	}

	return contactRequests1, nil
}

func (user0 *User) InsertToUserContactRequests(ctx context.Context, exec bob.Executor, related ...*ContactRequestSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	contactRequests1, err := insertUserToUserContactRequests0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.ToUserContactRequests = append(user0.R.ToUserContactRequests, contactRequests1...)

	for _, rel := range contactRequests1 {
		rel.R.ToUserUser = user0
	}
	return nil
}

func (user0 *User) AttachToUserContactRequests(ctx context.Context, exec bob.Executor, related ...*ContactRequest) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	contactRequests1 := ContactRequestSlice(related)

	_, err = attachUserToUserContactRequests0(ctx, exec, len(related), contactRequests1, user0)
	if err != nil {
		return err
	}

	user0.R.ToUserContactRequests = append(user0.R.ToUserContactRequests, contactRequests1...)

	for _, rel := range related {
		rel.R.ToUserUser = user0
	}

	return nil
}

func insertUserContactContacts0(ctx context.Context, exec bob.Executor, contacts1 []*ContactSetter, user0 *User) (ContactSlice, error) {
	for i := range contacts1 {
		contacts1[i].ContactID = omit.From(user0.ID)
	}

	ret, err := Contacts.Insert(bob.ToMods(contacts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserContactContacts0: %w", err)
	}

	return ret, nil
}

func attachUserContactContacts0(ctx context.Context, exec bob.Executor, count int, contacts1 ContactSlice, user0 *User) (ContactSlice, error) {
	setter := &ContactSetter{
		ContactID: omit.From(user0.ID),
	}

	err := contacts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserContactContacts0: %w", err)
	}

	return contacts1, nil
}

func (user0 *User) InsertContactContacts(ctx context.Context, exec bob.Executor, related ...*ContactSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	contacts1, err := insertUserContactContacts0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.ContactContacts = append(user0.R.ContactContacts, contacts1...)

	for _, rel := range contacts1 {
		rel.R.ContactUser = user0
	}
	return nil
}

func (user0 *User) AttachContactContacts(ctx context.Context, exec bob.Executor, related ...*Contact) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	contacts1 := ContactSlice(related)

	_, err = attachUserContactContacts0(ctx, exec, len(related), contacts1, user0)
	if err != nil {
		return err
	}

	user0.R.ContactContacts = append(user0.R.ContactContacts, contacts1...)

	for _, rel := range related {
		rel.R.ContactUser = user0
	}

	return nil
}

func insertUserContacts0(ctx context.Context, exec bob.Executor, contacts1 []*ContactSetter, user0 *User) (ContactSlice, error) {
	for i := range contacts1 {
		contacts1[i].UserID = omit.From(user0.ID)
	}

	ret, err := Contacts.Insert(bob.ToMods(contacts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserContacts0: %w", err)
	}

	return ret, nil
}

func attachUserContacts0(ctx context.Context, exec bob.Executor, count int, contacts1 ContactSlice, user0 *User) (ContactSlice, error) {
	setter := &ContactSetter{
		UserID: omit.From(user0.ID),
	}

	err := contacts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserContacts0: %w", err)
	}

	return contacts1, nil
}

func (user0 *User) InsertContacts(ctx context.Context, exec bob.Executor, related ...*ContactSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	contacts1, err := insertUserContacts0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.Contacts = append(user0.R.Contacts, contacts1...)

	for _, rel := range contacts1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachContacts(ctx context.Context, exec bob.Executor, related ...*Contact) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	contacts1 := ContactSlice(related)

	_, err = attachUserContacts0(ctx, exec, len(related), contacts1, user0)
	if err != nil {
		return err
	}

	user0.R.Contacts = append(user0.R.Contacts, contacts1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserConversationParticipants0(ctx context.Context, exec bob.Executor, conversationParticipants1 []*ConversationParticipantSetter, user0 *User) (ConversationParticipantSlice, error) {
	for i := range conversationParticipants1 {
		conversationParticipants1[i].UserID = omit.From(user0.ID)
	}

	ret, err := ConversationParticipants.Insert(bob.ToMods(conversationParticipants1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserConversationParticipants0: %w", err)
	}

	return ret, nil
}

func attachUserConversationParticipants0(ctx context.Context, exec bob.Executor, count int, conversationParticipants1 ConversationParticipantSlice, user0 *User) (ConversationParticipantSlice, error) {
	setter := &ConversationParticipantSetter{
		UserID: omit.From(user0.ID),
	}

	err := conversationParticipants1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserConversationParticipants0: %w", err)
	}

	return conversationParticipants1, nil
}

func (user0 *User) InsertConversationParticipants(ctx context.Context, exec bob.Executor, related ...*ConversationParticipantSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	conversationParticipants1, err := insertUserConversationParticipants0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.ConversationParticipants = append(user0.R.ConversationParticipants, conversationParticipants1...)

	for _, rel := range conversationParticipants1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachConversationParticipants(ctx context.Context, exec bob.Executor, related ...*ConversationParticipant) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	conversationParticipants1 := ConversationParticipantSlice(related)

	_, err = attachUserConversationParticipants0(ctx, exec, len(related), conversationParticipants1, user0)
	if err != nil {
		return err
	}

	user0.R.ConversationParticipants = append(user0.R.ConversationParticipants, conversationParticipants1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserLocationHistories0(ctx context.Context, exec bob.Executor, locationHistories1 []*LocationHistorySetter, user0 *User) (LocationHistorySlice, error) {
	for i := range locationHistories1 {
		locationHistories1[i].UserID = omit.From(user0.ID)
	}

	ret, err := LocationHistories.Insert(bob.ToMods(locationHistories1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserLocationHistories0: %w", err)
	}

	return ret, nil
}

func attachUserLocationHistories0(ctx context.Context, exec bob.Executor, count int, locationHistories1 LocationHistorySlice, user0 *User) (LocationHistorySlice, error) {
	setter := &LocationHistorySetter{
		UserID: omit.From(user0.ID),
	}

	err := locationHistories1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserLocationHistories0: %w", err)
	}

	return locationHistories1, nil
}

func (user0 *User) InsertLocationHistories(ctx context.Context, exec bob.Executor, related ...*LocationHistorySetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	locationHistories1, err := insertUserLocationHistories0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.LocationHistories = append(user0.R.LocationHistories, locationHistories1...)

	for _, rel := range locationHistories1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachLocationHistories(ctx context.Context, exec bob.Executor, related ...*LocationHistory) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	locationHistories1 := LocationHistorySlice(related)

	_, err = attachUserLocationHistories0(ctx, exec, len(related), locationHistories1, user0)
	if err != nil {
		return err
	}

	user0.R.LocationHistories = append(user0.R.LocationHistories, locationHistories1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserMedia0(ctx context.Context, exec bob.Executor, media1 []*MediumSetter, user0 *User) (MediumSlice, error) {
	for i := range media1 {
		media1[i].UserID = omit.From(user0.ID)
	}

	ret, err := Media.Insert(bob.ToMods(media1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserMedia0: %w", err)
	}

	return ret, nil
}

func attachUserMedia0(ctx context.Context, exec bob.Executor, count int, media1 MediumSlice, user0 *User) (MediumSlice, error) {
	setter := &MediumSetter{
		UserID: omit.From(user0.ID),
	}

	err := media1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserMedia0: %w", err)
	}

	return media1, nil
}

func (user0 *User) InsertMedia(ctx context.Context, exec bob.Executor, related ...*MediumSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	media1, err := insertUserMedia0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.Media = append(user0.R.Media, media1...)

	for _, rel := range media1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachMedia(ctx context.Context, exec bob.Executor, related ...*Medium) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	media1 := MediumSlice(related)

	_, err = attachUserMedia0(ctx, exec, len(related), media1, user0)
	if err != nil {
		return err
	}

	user0.R.Media = append(user0.R.Media, media1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserMessageDeletions0(ctx context.Context, exec bob.Executor, messageDeletions1 []*MessageDeletionSetter, user0 *User) (MessageDeletionSlice, error) {
	for i := range messageDeletions1 {
		messageDeletions1[i].UserID = omit.From(user0.ID)
	}

	ret, err := MessageDeletions.Insert(bob.ToMods(messageDeletions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserMessageDeletions0: %w", err)
	}

	return ret, nil
}

func attachUserMessageDeletions0(ctx context.Context, exec bob.Executor, count int, messageDeletions1 MessageDeletionSlice, user0 *User) (MessageDeletionSlice, error) {
	setter := &MessageDeletionSetter{
		UserID: omit.From(user0.ID),
	}

	err := messageDeletions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserMessageDeletions0: %w", err)
	}

	return messageDeletions1, nil
}

func (user0 *User) InsertMessageDeletions(ctx context.Context, exec bob.Executor, related ...*MessageDeletionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	messageDeletions1, err := insertUserMessageDeletions0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.MessageDeletions = append(user0.R.MessageDeletions, messageDeletions1...)

	for _, rel := range messageDeletions1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachMessageDeletions(ctx context.Context, exec bob.Executor, related ...*MessageDeletion) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	messageDeletions1 := MessageDeletionSlice(related)

	_, err = attachUserMessageDeletions0(ctx, exec, len(related), messageDeletions1, user0)
	if err != nil {
		return err
	}

	user0.R.MessageDeletions = append(user0.R.MessageDeletions, messageDeletions1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserMessageReactions0(ctx context.Context, exec bob.Executor, messageReactions1 []*MessageReactionSetter, user0 *User) (MessageReactionSlice, error) {
	for i := range messageReactions1 {
		messageReactions1[i].UserID = omit.From(user0.ID)
	}

	ret, err := MessageReactions.Insert(bob.ToMods(messageReactions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserMessageReactions0: %w", err)
	}

	return ret, nil
}

func attachUserMessageReactions0(ctx context.Context, exec bob.Executor, count int, messageReactions1 MessageReactionSlice, user0 *User) (MessageReactionSlice, error) {
	setter := &MessageReactionSetter{
		UserID: omit.From(user0.ID),
	}

	err := messageReactions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserMessageReactions0: %w", err)
	}

	return messageReactions1, nil
}

func (user0 *User) InsertMessageReactions(ctx context.Context, exec bob.Executor, related ...*MessageReactionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	messageReactions1, err := insertUserMessageReactions0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.MessageReactions = append(user0.R.MessageReactions, messageReactions1...)

	for _, rel := range messageReactions1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachMessageReactions(ctx context.Context, exec bob.Executor, related ...*MessageReaction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	messageReactions1 := MessageReactionSlice(related)

	_, err = attachUserMessageReactions0(ctx, exec, len(related), messageReactions1, user0)
	if err != nil {
		return err
	}

	user0.R.MessageReactions = append(user0.R.MessageReactions, messageReactions1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserMessageReceipts0(ctx context.Context, exec bob.Executor, messageReceipts1 []*MessageReceiptSetter, user0 *User) (MessageReceiptSlice, error) {
	for i := range messageReceipts1 {
		messageReceipts1[i].UserID = omit.From(user0.ID)
	}

	ret, err := MessageReceipts.Insert(bob.ToMods(messageReceipts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserMessageReceipts0: %w", err)
	}

	return ret, nil
}

func attachUserMessageReceipts0(ctx context.Context, exec bob.Executor, count int, messageReceipts1 MessageReceiptSlice, user0 *User) (MessageReceiptSlice, error) {
	setter := &MessageReceiptSetter{
		UserID: omit.From(user0.ID),
	}

	err := messageReceipts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserMessageReceipts0: %w", err)
	}

	return messageReceipts1, nil
}

func (user0 *User) InsertMessageReceipts(ctx context.Context, exec bob.Executor, related ...*MessageReceiptSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	messageReceipts1, err := insertUserMessageReceipts0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.MessageReceipts = append(user0.R.MessageReceipts, messageReceipts1...)

	for _, rel := range messageReceipts1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachMessageReceipts(ctx context.Context, exec bob.Executor, related ...*MessageReceipt) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	messageReceipts1 := MessageReceiptSlice(related)

	_, err = attachUserMessageReceipts0(ctx, exec, len(related), messageReceipts1, user0)
	if err != nil {
		return err
	}

	user0.R.MessageReceipts = append(user0.R.MessageReceipts, messageReceipts1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserSenderMessages0(ctx context.Context, exec bob.Executor, messages1 []*MessageSetter, user0 *User) (MessageSlice, error) {
	for i := range messages1 {
		messages1[i].SenderID = omit.From(user0.ID)
	}

	ret, err := Messages.Insert(bob.ToMods(messages1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserSenderMessages0: %w", err)
	}

	return ret, nil
}

func attachUserSenderMessages0(ctx context.Context, exec bob.Executor, count int, messages1 MessageSlice, user0 *User) (MessageSlice, error) {
	setter := &MessageSetter{
		SenderID: omit.From(user0.ID),
	}

	err := messages1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserSenderMessages0: %w", err)
	}

	return messages1, nil
}

func (user0 *User) InsertSenderMessages(ctx context.Context, exec bob.Executor, related ...*MessageSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	messages1, err := insertUserSenderMessages0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.SenderMessages = append(user0.R.SenderMessages, messages1...)

	for _, rel := range messages1 {
		rel.R.SenderUser = user0
	}
	return nil
}

func (user0 *User) AttachSenderMessages(ctx context.Context, exec bob.Executor, related ...*Message) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	messages1 := MessageSlice(related)

	_, err = attachUserSenderMessages0(ctx, exec, len(related), messages1, user0)
	if err != nil {
		return err
	}

	user0.R.SenderMessages = append(user0.R.SenderMessages, messages1...)

	for _, rel := range related {
		rel.R.SenderUser = user0
	}

	return nil
}

func insertUserPlaces0(ctx context.Context, exec bob.Executor, places1 []*PlaceSetter, user0 *User) (PlaceSlice, error) {
	for i := range places1 {
		places1[i].UserID = omit.From(user0.ID)
	}

	ret, err := Places.Insert(bob.ToMods(places1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserPlaces0: %w", err)
	}

	return ret, nil
}

func attachUserPlaces0(ctx context.Context, exec bob.Executor, count int, places1 PlaceSlice, user0 *User) (PlaceSlice, error) {
	setter := &PlaceSetter{
		UserID: omit.From(user0.ID),
	}

	err := places1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserPlaces0: %w", err)
	}

	return places1, nil
}

func (user0 *User) InsertPlaces(ctx context.Context, exec bob.Executor, related ...*PlaceSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	places1, err := insertUserPlaces0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.Places = append(user0.R.Places, places1...)

	for _, rel := range places1 {
		rel.R.User = user0
	}
	return nil
}

func (user0 *User) AttachPlaces(ctx context.Context, exec bob.Executor, related ...*Place) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	places1 := PlaceSlice(related)

	_, err = attachUserPlaces0(ctx, exec, len(related), places1, user0)
	if err != nil {
		return err
	}

	user0.R.Places = append(user0.R.Places, places1...)

	for _, rel := range related {
		rel.R.User = user0
	}

	return nil
}

func insertUserUserAvailability0(ctx context.Context, exec bob.Executor, userAvailability1 *UserAvailabilitySetter, user0 *User) (*UserAvailability, error) {
	userAvailability1.UserID = omit.From(user0.ID)

	ret, err := UserAvailabilities.Insert(userAvailability1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserUserAvailability0: %w", err)
	}

	return ret, nil
}

func attachUserUserAvailability0(ctx context.Context, exec bob.Executor, count int, userAvailability1 *UserAvailability, user0 *User) (*UserAvailability, error) {
	setter := &UserAvailabilitySetter{
		UserID: omit.From(user0.ID),
	}

	err := userAvailability1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserUserAvailability0: %w", err)
	}

	return userAvailability1, nil
}

func (user0 *User) InsertUserAvailability(ctx context.Context, exec bob.Executor, related *UserAvailabilitySetter) error {
	var err error

	userAvailability1, err := insertUserUserAvailability0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.UserAvailability = userAvailability1

	userAvailability1.R.User = user0

	return nil
}

func (user0 *User) AttachUserAvailability(ctx context.Context, exec bob.Executor, userAvailability1 *UserAvailability) error {
	var err error

	_, err = attachUserUserAvailability0(ctx, exec, 1, userAvailability1, user0)
	if err != nil {
		return err
	}

	user0.R.UserAvailability = userAvailability1

	userAvailability1.R.User = user0

	return nil
}

func insertUserUserLocation0(ctx context.Context, exec bob.Executor, userLocation1 *UserLocationSetter, user0 *User) (*UserLocation, error) {
	userLocation1.UserID = omit.From(user0.ID)

	ret, err := UserLocations.Insert(userLocation1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserUserLocation0: %w", err)
	}

	return ret, nil
}

func attachUserUserLocation0(ctx context.Context, exec bob.Executor, count int, userLocation1 *UserLocation, user0 *User) (*UserLocation, error) {
	setter := &UserLocationSetter{
		UserID: omit.From(user0.ID),
	}

	err := userLocation1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserUserLocation0: %w", err)
	}

	return userLocation1, nil
}

func (user0 *User) InsertUserLocation(ctx context.Context, exec bob.Executor, related *UserLocationSetter) error {
	var err error

	userLocation1, err := insertUserUserLocation0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.UserLocation = userLocation1

	userLocation1.R.User = user0

	return nil
}

func (user0 *User) AttachUserLocation(ctx context.Context, exec bob.Executor, userLocation1 *UserLocation) error {
	var err error

	_, err = attachUserUserLocation0(ctx, exec, 1, userLocation1, user0)
	if err != nil {
		return err
	}

	user0.R.UserLocation = userLocation1

	userLocation1.R.User = user0

	return nil
}

func insertUserUserPreference0(ctx context.Context, exec bob.Executor, userPreference1 *UserPreferenceSetter, user0 *User) (*UserPreference, error) {
	userPreference1.UserID = omit.From(user0.ID)

	ret, err := UserPreferences.Insert(userPreference1).One(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertUserUserPreference0: %w", err)
	}

	return ret, nil
}

func attachUserUserPreference0(ctx context.Context, exec bob.Executor, count int, userPreference1 *UserPreference, user0 *User) (*UserPreference, error) {
	setter := &UserPreferenceSetter{
		UserID: omit.From(user0.ID),
	}

	err := userPreference1.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachUserUserPreference0: %w", err)
	}

	return userPreference1, nil
}

func (user0 *User) InsertUserPreference(ctx context.Context, exec bob.Executor, related *UserPreferenceSetter) error {
	var err error

	userPreference1, err := insertUserUserPreference0(ctx, exec, related, user0)
	if err != nil {
		return err
	}

	user0.R.UserPreference = userPreference1

	userPreference1.R.User = user0

	return nil
}

func (user0 *User) AttachUserPreference(ctx context.Context, exec bob.Executor, userPreference1 *UserPreference) error {
	var err error

	_, err = attachUserUserPreference0(ctx, exec, 1, userPreference1, user0)
	if err != nil {
		return err
	}

	user0.R.UserPreference = userPreference1

	userPreference1.R.User = user0

	return nil
}

type userWhere[Q psql.Filterable] struct {
	ID          psql.WhereMod[Q, uuid.UUID]
	Auth0Sub    psql.WhereMod[Q, string]
	DisplayName psql.WhereMod[Q, string]
	Avatar      psql.WhereNullMod[Q, string]
	Bio         psql.WhereNullMod[Q, string]
	PhoneNumber psql.WhereNullMod[Q, string]
	Timezone    psql.WhereMod[Q, string]
	CreatedAt   psql.WhereMod[Q, time.Time]
	UpdatedAt   psql.WhereMod[Q, time.Time]
}

func (userWhere[Q]) AliasedAs(alias string) userWhere[Q] {
	return buildUserWhere[Q](buildUserColumns(alias))
}

func buildUserWhere[Q psql.Filterable](cols userColumns) userWhere[Q] {
	return userWhere[Q]{
		ID:          psql.Where[Q, uuid.UUID](cols.ID),
		Auth0Sub:    psql.Where[Q, string](cols.Auth0Sub),
		DisplayName: psql.Where[Q, string](cols.DisplayName),
		Avatar:      psql.WhereNull[Q, string](cols.Avatar),
		Bio:         psql.WhereNull[Q, string](cols.Bio),
		PhoneNumber: psql.WhereNull[Q, string](cols.PhoneNumber),
		Timezone:    psql.Where[Q, string](cols.Timezone),
		CreatedAt:   psql.Where[Q, time.Time](cols.CreatedAt),
		UpdatedAt:   psql.Where[Q, time.Time](cols.UpdatedAt),
	}
}

func (o *User) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "AvailabilityAutoRules":
		rels, ok := retrieved.(AvailabilityAutoRuleSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.AvailabilityAutoRules = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "AvailabilityWindows":
		rels, ok := retrieved.(AvailabilityWindowSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.AvailabilityWindows = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "CheckIns":
		rels, ok := retrieved.(CheckInSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CheckIns = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "InviteeCircleInvitations":
		rels, ok := retrieved.(CircleInvitationSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.InviteeCircleInvitations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.InviteeUser = o
			}
		}
		return nil
	case "InviterCircleInvitations":
		rels, ok := retrieved.(CircleInvitationSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.InviterCircleInvitations = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.InviterUser = o
			}
		}
		return nil
	case "CircleMembers":
		rels, ok := retrieved.(CircleMemberSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CircleMembers = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "CircleSharingPreferences":
		rels, ok := retrieved.(CircleSharingPreferenceSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CircleSharingPreferences = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "CreatedByCircles":
		rels, ok := retrieved.(CircleSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.CreatedByCircles = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.CreatedByUser = o
			}
		}
		return nil
	case "FromUserContactRequests":
		rels, ok := retrieved.(ContactRequestSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.FromUserContactRequests = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.FromUserUser = o
			}
		}
		return nil
	case "ToUserContactRequests":
		rels, ok := retrieved.(ContactRequestSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.ToUserContactRequests = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ToUserUser = o
			}
		}
		return nil
	case "ContactContacts":
		rels, ok := retrieved.(ContactSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.ContactContacts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.ContactUser = o
			}
		}
		return nil
	case "Contacts":
		rels, ok := retrieved.(ContactSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.Contacts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "ConversationParticipants":
		rels, ok := retrieved.(ConversationParticipantSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.ConversationParticipants = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "LocationHistories":
		rels, ok := retrieved.(LocationHistorySlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.LocationHistories = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "Media":
		rels, ok := retrieved.(MediumSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.Media = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "MessageDeletions":
		rels, ok := retrieved.(MessageDeletionSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.MessageDeletions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "MessageReactions":
		rels, ok := retrieved.(MessageReactionSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.MessageReactions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "MessageReceipts":
		rels, ok := retrieved.(MessageReceiptSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.MessageReceipts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "SenderMessages":
		rels, ok := retrieved.(MessageSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.SenderMessages = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.SenderUser = o
			}
		}
		return nil
	case "Places":
		rels, ok := retrieved.(PlaceSlice)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.Places = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.User = o
			}
		}
		return nil
	case "UserAvailability":
		rel, ok := retrieved.(*UserAvailability)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.UserAvailability = rel

		if rel != nil {
			rel.R.User = o
		}
		return nil
	case "UserLocation":
		rel, ok := retrieved.(*UserLocation)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.UserLocation = rel

		if rel != nil {
			rel.R.User = o
		}
		return nil
	case "UserPreference":
		rel, ok := retrieved.(*UserPreference)
		if !ok {
			return fmt.Errorf("user cannot load %T as %q", retrieved, name)
		}

		o.R.UserPreference = rel

		if rel != nil {
			rel.R.User = o
		}
		return nil
	default:
		return fmt.Errorf("user has no relationship %q", name)
	}
}

type userPreloader struct {
	UserAvailability func(...psql.PreloadOption) psql.Preloader
	UserLocation     func(...psql.PreloadOption) psql.Preloader
	UserPreference   func(...psql.PreloadOption) psql.Preloader
}

func buildUserPreloader() userPreloader {
	return userPreloader{
		UserAvailability: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*UserAvailability, UserAvailabilitySlice](psql.PreloadRel{
				Name: "UserAvailability",
				Sides: []psql.PreloadSide{
					{
						From:        Users,
						To:          UserAvailabilities,
						FromColumns: []string{"id"},
						ToColumns:   []string{"user_id"},
					},
				},
			}, UserAvailabilities.Columns.Names(), opts...)
		},
		UserLocation: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*UserLocation, UserLocationSlice](psql.PreloadRel{
				Name: "UserLocation",
				Sides: []psql.PreloadSide{
					{
						From:        Users,
						To:          UserLocations,
						FromColumns: []string{"id"},
						ToColumns:   []string{"user_id"},
					},
				},
			}, UserLocations.Columns.Names(), opts...)
		},
		UserPreference: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*UserPreference, UserPreferenceSlice](psql.PreloadRel{
				Name: "UserPreference",
				Sides: []psql.PreloadSide{
					{
						From:        Users,
						To:          UserPreferences,
						FromColumns: []string{"id"},
						ToColumns:   []string{"user_id"},
					},
				},
			}, UserPreferences.Columns.Names(), opts...)
		},
	}
}

type userThenLoader[Q orm.Loadable] struct {
	AvailabilityAutoRules    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	AvailabilityWindows      func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CheckIns                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	InviteeCircleInvitations func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	InviterCircleInvitations func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CircleMembers            func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CircleSharingPreferences func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	CreatedByCircles         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	FromUserContactRequests  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ToUserContactRequests    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ContactContacts          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Contacts                 func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	ConversationParticipants func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	LocationHistories        func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Media                    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	MessageDeletions         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	MessageReactions         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	MessageReceipts          func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SenderMessages           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Places                   func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	UserAvailability         func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	UserLocation             func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	UserPreference           func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildUserThenLoader[Q orm.Loadable]() userThenLoader[Q] {
	type AvailabilityAutoRulesLoadInterface interface {
		LoadAvailabilityAutoRules(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type AvailabilityWindowsLoadInterface interface {
		LoadAvailabilityWindows(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CheckInsLoadInterface interface {
		LoadCheckIns(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type InviteeCircleInvitationsLoadInterface interface {
		LoadInviteeCircleInvitations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type InviterCircleInvitationsLoadInterface interface {
		LoadInviterCircleInvitations(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CircleMembersLoadInterface interface {
		LoadCircleMembers(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CircleSharingPreferencesLoadInterface interface {
		LoadCircleSharingPreferences(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CreatedByCirclesLoadInterface interface {
		LoadCreatedByCircles(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type FromUserContactRequestsLoadInterface interface {
		LoadFromUserContactRequests(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ToUserContactRequestsLoadInterface interface {
		LoadToUserContactRequests(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ContactContactsLoadInterface interface {
		LoadContactContacts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ContactsLoadInterface interface {
		LoadContacts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ConversationParticipantsLoadInterface interface {
		LoadConversationParticipants(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type LocationHistoriesLoadInterface interface {
		LoadLocationHistories(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MediaLoadInterface interface {
		LoadMedia(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MessageDeletionsLoadInterface interface {
		LoadMessageDeletions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MessageReactionsLoadInterface interface {
		LoadMessageReactions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MessageReceiptsLoadInterface interface {
		LoadMessageReceipts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SenderMessagesLoadInterface interface {
		LoadSenderMessages(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type PlacesLoadInterface interface {
		LoadPlaces(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserAvailabilityLoadInterface interface {
		LoadUserAvailability(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserLocationLoadInterface interface {
		LoadUserLocation(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type UserPreferenceLoadInterface interface {
		LoadUserPreference(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return userThenLoader[Q]{
		AvailabilityAutoRules: thenLoadBuilder[Q](
			"AvailabilityAutoRules",
			func(ctx context.Context, exec bob.Executor, retrieved AvailabilityAutoRulesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAvailabilityAutoRules(ctx, exec, mods...)
			},
		),
		AvailabilityWindows: thenLoadBuilder[Q](
			"AvailabilityWindows",
			func(ctx context.Context, exec bob.Executor, retrieved AvailabilityWindowsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadAvailabilityWindows(ctx, exec, mods...)
			},
		),
		CheckIns: thenLoadBuilder[Q](
			"CheckIns",
			func(ctx context.Context, exec bob.Executor, retrieved CheckInsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCheckIns(ctx, exec, mods...)
			},
		),
		InviteeCircleInvitations: thenLoadBuilder[Q](
			"InviteeCircleInvitations",
			func(ctx context.Context, exec bob.Executor, retrieved InviteeCircleInvitationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadInviteeCircleInvitations(ctx, exec, mods...)
			},
		),
		InviterCircleInvitations: thenLoadBuilder[Q](
			"InviterCircleInvitations",
			func(ctx context.Context, exec bob.Executor, retrieved InviterCircleInvitationsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadInviterCircleInvitations(ctx, exec, mods...)
			},
		),
		CircleMembers: thenLoadBuilder[Q](
			"CircleMembers",
			func(ctx context.Context, exec bob.Executor, retrieved CircleMembersLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCircleMembers(ctx, exec, mods...)
			},
		),
		CircleSharingPreferences: thenLoadBuilder[Q](
			"CircleSharingPreferences",
			func(ctx context.Context, exec bob.Executor, retrieved CircleSharingPreferencesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCircleSharingPreferences(ctx, exec, mods...)
			},
		),
		CreatedByCircles: thenLoadBuilder[Q](
			"CreatedByCircles",
			func(ctx context.Context, exec bob.Executor, retrieved CreatedByCirclesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCreatedByCircles(ctx, exec, mods...)
			},
		),
		FromUserContactRequests: thenLoadBuilder[Q](
			"FromUserContactRequests",
			func(ctx context.Context, exec bob.Executor, retrieved FromUserContactRequestsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadFromUserContactRequests(ctx, exec, mods...)
			},
		),
		ToUserContactRequests: thenLoadBuilder[Q](
			"ToUserContactRequests",
			func(ctx context.Context, exec bob.Executor, retrieved ToUserContactRequestsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadToUserContactRequests(ctx, exec, mods...)
			},
		),
		ContactContacts: thenLoadBuilder[Q](
			"ContactContacts",
			func(ctx context.Context, exec bob.Executor, retrieved ContactContactsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadContactContacts(ctx, exec, mods...)
			},
		),
		Contacts: thenLoadBuilder[Q](
			"Contacts",
			func(ctx context.Context, exec bob.Executor, retrieved ContactsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadContacts(ctx, exec, mods...)
			},
		),
		ConversationParticipants: thenLoadBuilder[Q](
			"ConversationParticipants",
			func(ctx context.Context, exec bob.Executor, retrieved ConversationParticipantsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadConversationParticipants(ctx, exec, mods...)
			},
		),
		LocationHistories: thenLoadBuilder[Q](
			"LocationHistories",
			func(ctx context.Context, exec bob.Executor, retrieved LocationHistoriesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadLocationHistories(ctx, exec, mods...)
			},
		),
		Media: thenLoadBuilder[Q](
			"Media",
			func(ctx context.Context, exec bob.Executor, retrieved MediaLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMedia(ctx, exec, mods...)
			},
		),
		MessageDeletions: thenLoadBuilder[Q](
			"MessageDeletions",
			func(ctx context.Context, exec bob.Executor, retrieved MessageDeletionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMessageDeletions(ctx, exec, mods...)
			},
		),
		MessageReactions: thenLoadBuilder[Q](
			"MessageReactions",
			func(ctx context.Context, exec bob.Executor, retrieved MessageReactionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMessageReactions(ctx, exec, mods...)
			},
		),
		MessageReceipts: thenLoadBuilder[Q](
			"MessageReceipts",
			func(ctx context.Context, exec bob.Executor, retrieved MessageReceiptsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMessageReceipts(ctx, exec, mods...)
			},
		),
		SenderMessages: thenLoadBuilder[Q](
			"SenderMessages",
			func(ctx context.Context, exec bob.Executor, retrieved SenderMessagesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSenderMessages(ctx, exec, mods...)
			},
		),
		Places: thenLoadBuilder[Q](
			"Places",
			func(ctx context.Context, exec bob.Executor, retrieved PlacesLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadPlaces(ctx, exec, mods...)
			},
		),
		UserAvailability: thenLoadBuilder[Q](
			"UserAvailability",
			func(ctx context.Context, exec bob.Executor, retrieved UserAvailabilityLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUserAvailability(ctx, exec, mods...)
			},
		),
		UserLocation: thenLoadBuilder[Q](
			"UserLocation",
			func(ctx context.Context, exec bob.Executor, retrieved UserLocationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUserLocation(ctx, exec, mods...)
			},
		),
		UserPreference: thenLoadBuilder[Q](
			"UserPreference",
			func(ctx context.Context, exec bob.Executor, retrieved UserPreferenceLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadUserPreference(ctx, exec, mods...)
			},
		),
	}
}

// LoadAvailabilityAutoRules loads the user's AvailabilityAutoRules into the .R struct
func (o *User) LoadAvailabilityAutoRules(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AvailabilityAutoRules = nil

	related, err := o.AvailabilityAutoRules(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.AvailabilityAutoRules = related
	return nil
}

// LoadAvailabilityAutoRules loads the user's AvailabilityAutoRules into the .R struct
func (os UserSlice) LoadAvailabilityAutoRules(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	availabilityAutoRules, err := os.AvailabilityAutoRules(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.AvailabilityAutoRules = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range availabilityAutoRules {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.AvailabilityAutoRules = append(o.R.AvailabilityAutoRules, rel)
		}
	}

	return nil
}

// LoadAvailabilityWindows loads the user's AvailabilityWindows into the .R struct
func (o *User) LoadAvailabilityWindows(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.AvailabilityWindows = nil

	related, err := o.AvailabilityWindows(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.AvailabilityWindows = related
	return nil
}

// LoadAvailabilityWindows loads the user's AvailabilityWindows into the .R struct
func (os UserSlice) LoadAvailabilityWindows(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	availabilityWindows, err := os.AvailabilityWindows(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.AvailabilityWindows = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range availabilityWindows {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.AvailabilityWindows = append(o.R.AvailabilityWindows, rel)
		}
	}

	return nil
}

// LoadCheckIns loads the user's CheckIns into the .R struct
func (o *User) LoadCheckIns(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CheckIns = nil

	related, err := o.CheckIns(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.CheckIns = related
	return nil
}

// LoadCheckIns loads the user's CheckIns into the .R struct
func (os UserSlice) LoadCheckIns(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	checkIns, err := os.CheckIns(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.CheckIns = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range checkIns {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.CheckIns = append(o.R.CheckIns, rel)
		}
	}

	return nil
}

// LoadInviteeCircleInvitations loads the user's InviteeCircleInvitations into the .R struct
func (o *User) LoadInviteeCircleInvitations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.InviteeCircleInvitations = nil

	related, err := o.InviteeCircleInvitations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.InviteeUser = o
	}

	o.R.InviteeCircleInvitations = related
	return nil
}

// LoadInviteeCircleInvitations loads the user's InviteeCircleInvitations into the .R struct
func (os UserSlice) LoadInviteeCircleInvitations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	circleInvitations, err := os.InviteeCircleInvitations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.InviteeCircleInvitations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range circleInvitations {

			if !rel.InviteeID.IsValue() {
				continue
			}
			if !(rel.InviteeID.IsValue() && o.ID == rel.InviteeID.MustGet()) {
				continue
			}

			rel.R.InviteeUser = o

			o.R.InviteeCircleInvitations = append(o.R.InviteeCircleInvitations, rel)
		}
	}

	return nil
}

// LoadInviterCircleInvitations loads the user's InviterCircleInvitations into the .R struct
func (o *User) LoadInviterCircleInvitations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.InviterCircleInvitations = nil

	related, err := o.InviterCircleInvitations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.InviterUser = o
	}

	o.R.InviterCircleInvitations = related
	return nil
}

// LoadInviterCircleInvitations loads the user's InviterCircleInvitations into the .R struct
func (os UserSlice) LoadInviterCircleInvitations(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	circleInvitations, err := os.InviterCircleInvitations(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.InviterCircleInvitations = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range circleInvitations {

			if !(o.ID == rel.InviterID) {
				continue
			}

			rel.R.InviterUser = o

			o.R.InviterCircleInvitations = append(o.R.InviterCircleInvitations, rel)
		}
	}

	return nil
}

// LoadCircleMembers loads the user's CircleMembers into the .R struct
func (o *User) LoadCircleMembers(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CircleMembers = nil

	related, err := o.CircleMembers(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.CircleMembers = related
	return nil
}

// LoadCircleMembers loads the user's CircleMembers into the .R struct
func (os UserSlice) LoadCircleMembers(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	circleMembers, err := os.CircleMembers(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.CircleMembers = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range circleMembers {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.CircleMembers = append(o.R.CircleMembers, rel)
		}
	}

	return nil
}

// LoadCircleSharingPreferences loads the user's CircleSharingPreferences into the .R struct
func (o *User) LoadCircleSharingPreferences(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CircleSharingPreferences = nil

	related, err := o.CircleSharingPreferences(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.CircleSharingPreferences = related
	return nil
}

// LoadCircleSharingPreferences loads the user's CircleSharingPreferences into the .R struct
func (os UserSlice) LoadCircleSharingPreferences(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	circleSharingPreferences, err := os.CircleSharingPreferences(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.CircleSharingPreferences = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range circleSharingPreferences {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.CircleSharingPreferences = append(o.R.CircleSharingPreferences, rel)
		}
	}

	return nil
}

// LoadCreatedByCircles loads the user's CreatedByCircles into the .R struct
func (o *User) LoadCreatedByCircles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.CreatedByCircles = nil

	related, err := o.CreatedByCircles(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.CreatedByUser = o
	}

	o.R.CreatedByCircles = related
	return nil
}

// LoadCreatedByCircles loads the user's CreatedByCircles into the .R struct
func (os UserSlice) LoadCreatedByCircles(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	circles, err := os.CreatedByCircles(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.CreatedByCircles = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range circles {

			if !(o.ID == rel.CreatedBy) {
				continue
			}

			rel.R.CreatedByUser = o

			o.R.CreatedByCircles = append(o.R.CreatedByCircles, rel)
		}
	}

	return nil
}

// LoadFromUserContactRequests loads the user's FromUserContactRequests into the .R struct
func (o *User) LoadFromUserContactRequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.FromUserContactRequests = nil

	related, err := o.FromUserContactRequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.FromUserUser = o
	}

	o.R.FromUserContactRequests = related
	return nil
}

// LoadFromUserContactRequests loads the user's FromUserContactRequests into the .R struct
func (os UserSlice) LoadFromUserContactRequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	contactRequests, err := os.FromUserContactRequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.FromUserContactRequests = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range contactRequests {

			if !(o.ID == rel.FromUserID) {
				continue
			}

			rel.R.FromUserUser = o

			o.R.FromUserContactRequests = append(o.R.FromUserContactRequests, rel)
		}
	}

	return nil
}

// LoadToUserContactRequests loads the user's ToUserContactRequests into the .R struct
func (o *User) LoadToUserContactRequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ToUserContactRequests = nil

	related, err := o.ToUserContactRequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ToUserUser = o
	}

	o.R.ToUserContactRequests = related
	return nil
}

// LoadToUserContactRequests loads the user's ToUserContactRequests into the .R struct
func (os UserSlice) LoadToUserContactRequests(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	contactRequests, err := os.ToUserContactRequests(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.ToUserContactRequests = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range contactRequests {

			if !(o.ID == rel.ToUserID) {
				continue
			}

			rel.R.ToUserUser = o

			o.R.ToUserContactRequests = append(o.R.ToUserContactRequests, rel)
		}
	}

	return nil
}

// LoadContactContacts loads the user's ContactContacts into the .R struct
func (o *User) LoadContactContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ContactContacts = nil

	related, err := o.ContactContacts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.ContactUser = o
	}

	o.R.ContactContacts = related
	return nil
}

// LoadContactContacts loads the user's ContactContacts into the .R struct
func (os UserSlice) LoadContactContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	contacts, err := os.ContactContacts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.ContactContacts = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range contacts {

			if !(o.ID == rel.ContactID) {
				continue
			}

			rel.R.ContactUser = o

			o.R.ContactContacts = append(o.R.ContactContacts, rel)
		}
	}

	return nil
}

// LoadContacts loads the user's Contacts into the .R struct
func (o *User) LoadContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Contacts = nil

	related, err := o.Contacts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.Contacts = related
	return nil
}

// LoadContacts loads the user's Contacts into the .R struct
func (os UserSlice) LoadContacts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	contacts, err := os.Contacts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Contacts = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range contacts {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.Contacts = append(o.R.Contacts, rel)
		}
	}

	return nil
}

// LoadConversationParticipants loads the user's ConversationParticipants into the .R struct
func (o *User) LoadConversationParticipants(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.ConversationParticipants = nil

	related, err := o.ConversationParticipants(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.ConversationParticipants = related
	return nil
}

// LoadConversationParticipants loads the user's ConversationParticipants into the .R struct
func (os UserSlice) LoadConversationParticipants(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	conversationParticipants, err := os.ConversationParticipants(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.ConversationParticipants = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range conversationParticipants {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.ConversationParticipants = append(o.R.ConversationParticipants, rel)
		}
	}

	return nil
}

// LoadLocationHistories loads the user's LocationHistories into the .R struct
func (o *User) LoadLocationHistories(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.LocationHistories = nil

	related, err := o.LocationHistories(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.LocationHistories = related
	return nil
}

// LoadLocationHistories loads the user's LocationHistories into the .R struct
func (os UserSlice) LoadLocationHistories(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	locationHistories, err := os.LocationHistories(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.LocationHistories = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range locationHistories {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.LocationHistories = append(o.R.LocationHistories, rel)
		}
	}

	return nil
}

// LoadMedia loads the user's Media into the .R struct
func (o *User) LoadMedia(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Media = nil

	related, err := o.Media(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.Media = related
	return nil
}

// LoadMedia loads the user's Media into the .R struct
func (os UserSlice) LoadMedia(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	media, err := os.Media(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Media = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range media {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.Media = append(o.R.Media, rel)
		}
	}

	return nil
}

// LoadMessageDeletions loads the user's MessageDeletions into the .R struct
func (o *User) LoadMessageDeletions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.MessageDeletions = nil

	related, err := o.MessageDeletions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.MessageDeletions = related
	return nil
}

// LoadMessageDeletions loads the user's MessageDeletions into the .R struct
func (os UserSlice) LoadMessageDeletions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	messageDeletions, err := os.MessageDeletions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.MessageDeletions = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range messageDeletions {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.MessageDeletions = append(o.R.MessageDeletions, rel)
		}
	}

	return nil
}

// LoadMessageReactions loads the user's MessageReactions into the .R struct
func (o *User) LoadMessageReactions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.MessageReactions = nil

	related, err := o.MessageReactions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.MessageReactions = related
	return nil
}

// LoadMessageReactions loads the user's MessageReactions into the .R struct
func (os UserSlice) LoadMessageReactions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	messageReactions, err := os.MessageReactions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.MessageReactions = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range messageReactions {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.MessageReactions = append(o.R.MessageReactions, rel)
		}
	}

	return nil
}

// LoadMessageReceipts loads the user's MessageReceipts into the .R struct
func (o *User) LoadMessageReceipts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.MessageReceipts = nil

	related, err := o.MessageReceipts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.MessageReceipts = related
	return nil
}

// LoadMessageReceipts loads the user's MessageReceipts into the .R struct
func (os UserSlice) LoadMessageReceipts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	messageReceipts, err := os.MessageReceipts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.MessageReceipts = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range messageReceipts {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.MessageReceipts = append(o.R.MessageReceipts, rel)
		}
	}

	return nil
}

// LoadSenderMessages loads the user's SenderMessages into the .R struct
func (o *User) LoadSenderMessages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SenderMessages = nil

	related, err := o.SenderMessages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.SenderUser = o
	}

	o.R.SenderMessages = related
	return nil
}

// LoadSenderMessages loads the user's SenderMessages into the .R struct
func (os UserSlice) LoadSenderMessages(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	messages, err := os.SenderMessages(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.SenderMessages = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range messages {

			if !(o.ID == rel.SenderID) {
				continue
			}

			rel.R.SenderUser = o

			o.R.SenderMessages = append(o.R.SenderMessages, rel)
		}
	}

	return nil
}

// LoadPlaces loads the user's Places into the .R struct
func (o *User) LoadPlaces(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Places = nil

	related, err := o.Places(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.User = o
	}

	o.R.Places = related
	return nil
}

// LoadPlaces loads the user's Places into the .R struct
func (os UserSlice) LoadPlaces(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	places, err := os.Places(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.Places = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range places {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.Places = append(o.R.Places, rel)
		}
	}

	return nil
}

// LoadUserAvailability loads the user's UserAvailability into the .R struct
func (o *User) LoadUserAvailability(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.UserAvailability = nil

	related, err := o.UserAvailability(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.User = o

	o.R.UserAvailability = related
	return nil
}

// LoadUserAvailability loads the user's UserAvailability into the .R struct
func (os UserSlice) LoadUserAvailability(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userAvailabilities, err := os.UserAvailability(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range userAvailabilities {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.UserAvailability = rel
			break
		}
	}

	return nil
}

// LoadUserLocation loads the user's UserLocation into the .R struct
func (o *User) LoadUserLocation(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.UserLocation = nil

	related, err := o.UserLocation(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.User = o

	o.R.UserLocation = related
	return nil
}

// LoadUserLocation loads the user's UserLocation into the .R struct
func (os UserSlice) LoadUserLocation(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userLocations, err := os.UserLocation(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range userLocations {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.UserLocation = rel
			break
		}
	}

	return nil
}

// LoadUserPreference loads the user's UserPreference into the .R struct
func (o *User) LoadUserPreference(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.UserPreference = nil

	related, err := o.UserPreference(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.User = o

	o.R.UserPreference = related
	return nil
}

// LoadUserPreference loads the user's UserPreference into the .R struct
func (os UserSlice) LoadUserPreference(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	userPreferences, err := os.UserPreference(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range userPreferences {

			if !(o.ID == rel.UserID) {
				continue
			}

			rel.R.User = o

			o.R.UserPreference = rel
			break
		}
	}

	return nil
}

type userJoins[Q dialect.Joinable] struct {
	typ                      string
	AvailabilityAutoRules    modAs[Q, availabilityAutoRuleColumns]
	AvailabilityWindows      modAs[Q, availabilityWindowColumns]
	CheckIns                 modAs[Q, checkInColumns]
	InviteeCircleInvitations modAs[Q, circleInvitationColumns]
	InviterCircleInvitations modAs[Q, circleInvitationColumns]
	CircleMembers            modAs[Q, circleMemberColumns]
	CircleSharingPreferences modAs[Q, circleSharingPreferenceColumns]
	CreatedByCircles         modAs[Q, circleColumns]
	FromUserContactRequests  modAs[Q, contactRequestColumns]
	ToUserContactRequests    modAs[Q, contactRequestColumns]
	ContactContacts          modAs[Q, contactColumns]
	Contacts                 modAs[Q, contactColumns]
	ConversationParticipants modAs[Q, conversationParticipantColumns]
	LocationHistories        modAs[Q, locationHistoryColumns]
	Media                    modAs[Q, mediumColumns]
	MessageDeletions         modAs[Q, messageDeletionColumns]
	MessageReactions         modAs[Q, messageReactionColumns]
	MessageReceipts          modAs[Q, messageReceiptColumns]
	SenderMessages           modAs[Q, messageColumns]
	Places                   modAs[Q, placeColumns]
	UserAvailability         modAs[Q, userAvailabilityColumns]
	UserLocation             modAs[Q, userLocationColumns]
	UserPreference           modAs[Q, userPreferenceColumns]
}

func (j userJoins[Q]) aliasedAs(alias string) userJoins[Q] {
	return buildUserJoins[Q](buildUserColumns(alias), j.typ)
}

func buildUserJoins[Q dialect.Joinable](cols userColumns, typ string) userJoins[Q] {
	return userJoins[Q]{
		typ: typ,
		AvailabilityAutoRules: modAs[Q, availabilityAutoRuleColumns]{
			c: AvailabilityAutoRules.Columns,
			f: func(to availabilityAutoRuleColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, AvailabilityAutoRules.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		AvailabilityWindows: modAs[Q, availabilityWindowColumns]{
			c: AvailabilityWindows.Columns,
			f: func(to availabilityWindowColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, AvailabilityWindows.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		CheckIns: modAs[Q, checkInColumns]{
			c: CheckIns.Columns,
			f: func(to checkInColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CheckIns.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		InviteeCircleInvitations: modAs[Q, circleInvitationColumns]{
			c: CircleInvitations.Columns,
			f: func(to circleInvitationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CircleInvitations.Name().As(to.Alias())).On(
						to.InviteeID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		InviterCircleInvitations: modAs[Q, circleInvitationColumns]{
			c: CircleInvitations.Columns,
			f: func(to circleInvitationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CircleInvitations.Name().As(to.Alias())).On(
						to.InviterID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		CircleMembers: modAs[Q, circleMemberColumns]{
			c: CircleMembers.Columns,
			f: func(to circleMemberColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CircleMembers.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		CircleSharingPreferences: modAs[Q, circleSharingPreferenceColumns]{
			c: CircleSharingPreferences.Columns,
			f: func(to circleSharingPreferenceColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, CircleSharingPreferences.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		CreatedByCircles: modAs[Q, circleColumns]{
			c: Circles.Columns,
			f: func(to circleColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Circles.Name().As(to.Alias())).On(
						to.CreatedBy.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		FromUserContactRequests: modAs[Q, contactRequestColumns]{
			c: ContactRequests.Columns,
			f: func(to contactRequestColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ContactRequests.Name().As(to.Alias())).On(
						to.FromUserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		ToUserContactRequests: modAs[Q, contactRequestColumns]{
			c: ContactRequests.Columns,
			f: func(to contactRequestColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ContactRequests.Name().As(to.Alias())).On(
						to.ToUserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		ContactContacts: modAs[Q, contactColumns]{
			c: Contacts.Columns,
			f: func(to contactColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Contacts.Name().As(to.Alias())).On(
						to.ContactID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Contacts: modAs[Q, contactColumns]{
			c: Contacts.Columns,
			f: func(to contactColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Contacts.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		ConversationParticipants: modAs[Q, conversationParticipantColumns]{
			c: ConversationParticipants.Columns,
			f: func(to conversationParticipantColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, ConversationParticipants.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		LocationHistories: modAs[Q, locationHistoryColumns]{
			c: LocationHistories.Columns,
			f: func(to locationHistoryColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, LocationHistories.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Media: modAs[Q, mediumColumns]{
			c: Media.Columns,
			f: func(to mediumColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Media.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		MessageDeletions: modAs[Q, messageDeletionColumns]{
			c: MessageDeletions.Columns,
			f: func(to messageDeletionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, MessageDeletions.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		MessageReactions: modAs[Q, messageReactionColumns]{
			c: MessageReactions.Columns,
			f: func(to messageReactionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, MessageReactions.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		MessageReceipts: modAs[Q, messageReceiptColumns]{
			c: MessageReceipts.Columns,
			f: func(to messageReceiptColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, MessageReceipts.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		SenderMessages: modAs[Q, messageColumns]{
			c: Messages.Columns,
			f: func(to messageColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Messages.Name().As(to.Alias())).On(
						to.SenderID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Places: modAs[Q, placeColumns]{
			c: Places.Columns,
			f: func(to placeColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Places.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		UserAvailability: modAs[Q, userAvailabilityColumns]{
			c: UserAvailabilities.Columns,
			f: func(to userAvailabilityColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserAvailabilities.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		UserLocation: modAs[Q, userLocationColumns]{
			c: UserLocations.Columns,
			f: func(to userLocationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserLocations.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		UserPreference: modAs[Q, userPreferenceColumns]{
			c: UserPreferences.Columns,
			f: func(to userPreferenceColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, UserPreferences.Name().As(to.Alias())).On(
						to.UserID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
	}
}
