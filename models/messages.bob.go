// Code generated by BobGen psql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/gofrs/uuid/v5"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
	"github.com/stephenafamo/bob/types/pgtypes"
)

// Message is an object representing the database table.
type Message struct {
	ID              uuid.UUID                             `db:"id,pk" `
	ConversationID  uuid.UUID                             `db:"conversation_id" `
	SenderID        uuid.UUID                             `db:"sender_id" `
	ContentType     string                                `db:"content_type" `
	ContentText     null.Val[string]                      `db:"content_text" `
	ContentMediaID  null.Val[uuid.UUID]                   `db:"content_media_id" `
	ContentMediaURL null.Val[string]                      `db:"content_media_url" `
	ContentMetadata null.Val[types.JSON[json.RawMessage]] `db:"content_metadata" `
	ReplyToID       null.Val[uuid.UUID]                   `db:"reply_to_id" `
	IsEdited        bool                                  `db:"is_edited" `
	EditedAt        null.Val[time.Time]                   `db:"edited_at" `
	DeletedForAll   bool                                  `db:"deleted_for_all" `
	CreatedAt       time.Time                             `db:"created_at" `

	R messageR `db:"-" `
}

// MessageSlice is an alias for a slice of pointers to Message.
// This should almost always be used instead of []*Message.
type MessageSlice []*Message

// Messages contains methods to work with the messages table
var Messages = psql.NewTablex[*Message, MessageSlice, *MessageSetter]("", "messages", buildMessageColumns("messages"))

// MessagesQuery is a query on the messages table
type MessagesQuery = *psql.ViewQuery[*Message, MessageSlice]

// messageR is where relationships are stored.
type messageR struct {
	MessageDeletions MessageDeletionSlice // message_deletions.fk_message_deletions_message_id
	MessageReactions MessageReactionSlice // message_reactions.fk_message_reactions_message_id
	MessageReceipts  MessageReceiptSlice  // message_receipts.fk_message_receipts_message_id
	Conversation     *Conversation        // messages.fk_messages_conversation_id
	SenderUser       *User                // messages.fk_messages_sender_id
}

func buildMessageColumns(alias string) messageColumns {
	return messageColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "conversation_id", "sender_id", "content_type", "content_text", "content_media_id", "content_media_url", "content_metadata", "reply_to_id", "is_edited", "edited_at", "deleted_for_all", "created_at",
		).WithParent("messages"),
		tableAlias:      alias,
		ID:              psql.Quote(alias, "id"),
		ConversationID:  psql.Quote(alias, "conversation_id"),
		SenderID:        psql.Quote(alias, "sender_id"),
		ContentType:     psql.Quote(alias, "content_type"),
		ContentText:     psql.Quote(alias, "content_text"),
		ContentMediaID:  psql.Quote(alias, "content_media_id"),
		ContentMediaURL: psql.Quote(alias, "content_media_url"),
		ContentMetadata: psql.Quote(alias, "content_metadata"),
		ReplyToID:       psql.Quote(alias, "reply_to_id"),
		IsEdited:        psql.Quote(alias, "is_edited"),
		EditedAt:        psql.Quote(alias, "edited_at"),
		DeletedForAll:   psql.Quote(alias, "deleted_for_all"),
		CreatedAt:       psql.Quote(alias, "created_at"),
	}
}

type messageColumns struct {
	expr.ColumnsExpr
	tableAlias      string
	ID              psql.Expression
	ConversationID  psql.Expression
	SenderID        psql.Expression
	ContentType     psql.Expression
	ContentText     psql.Expression
	ContentMediaID  psql.Expression
	ContentMediaURL psql.Expression
	ContentMetadata psql.Expression
	ReplyToID       psql.Expression
	IsEdited        psql.Expression
	EditedAt        psql.Expression
	DeletedForAll   psql.Expression
	CreatedAt       psql.Expression
}

func (c messageColumns) Alias() string {
	return c.tableAlias
}

func (messageColumns) AliasedAs(alias string) messageColumns {
	return buildMessageColumns(alias)
}

// MessageSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type MessageSetter struct {
	ID              omit.Val[uuid.UUID]                       `db:"id,pk" `
	ConversationID  omit.Val[uuid.UUID]                       `db:"conversation_id" `
	SenderID        omit.Val[uuid.UUID]                       `db:"sender_id" `
	ContentType     omit.Val[string]                          `db:"content_type" `
	ContentText     omitnull.Val[string]                      `db:"content_text" `
	ContentMediaID  omitnull.Val[uuid.UUID]                   `db:"content_media_id" `
	ContentMediaURL omitnull.Val[string]                      `db:"content_media_url" `
	ContentMetadata omitnull.Val[types.JSON[json.RawMessage]] `db:"content_metadata" `
	ReplyToID       omitnull.Val[uuid.UUID]                   `db:"reply_to_id" `
	IsEdited        omit.Val[bool]                            `db:"is_edited" `
	EditedAt        omitnull.Val[time.Time]                   `db:"edited_at" `
	DeletedForAll   omit.Val[bool]                            `db:"deleted_for_all" `
	CreatedAt       omit.Val[time.Time]                       `db:"created_at" `
}

func (s MessageSetter) SetColumns() []string {
	vals := make([]string, 0, 13)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.ConversationID.IsValue() {
		vals = append(vals, "conversation_id")
	}
	if s.SenderID.IsValue() {
		vals = append(vals, "sender_id")
	}
	if s.ContentType.IsValue() {
		vals = append(vals, "content_type")
	}
	if !s.ContentText.IsUnset() {
		vals = append(vals, "content_text")
	}
	if !s.ContentMediaID.IsUnset() {
		vals = append(vals, "content_media_id")
	}
	if !s.ContentMediaURL.IsUnset() {
		vals = append(vals, "content_media_url")
	}
	if !s.ContentMetadata.IsUnset() {
		vals = append(vals, "content_metadata")
	}
	if !s.ReplyToID.IsUnset() {
		vals = append(vals, "reply_to_id")
	}
	if s.IsEdited.IsValue() {
		vals = append(vals, "is_edited")
	}
	if !s.EditedAt.IsUnset() {
		vals = append(vals, "edited_at")
	}
	if s.DeletedForAll.IsValue() {
		vals = append(vals, "deleted_for_all")
	}
	if s.CreatedAt.IsValue() {
		vals = append(vals, "created_at")
	}
	return vals
}

func (s MessageSetter) Overwrite(t *Message) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.ConversationID.IsValue() {
		t.ConversationID = s.ConversationID.MustGet()
	}
	if s.SenderID.IsValue() {
		t.SenderID = s.SenderID.MustGet()
	}
	if s.ContentType.IsValue() {
		t.ContentType = s.ContentType.MustGet()
	}
	if !s.ContentText.IsUnset() {
		t.ContentText = s.ContentText.MustGetNull()
	}
	if !s.ContentMediaID.IsUnset() {
		t.ContentMediaID = s.ContentMediaID.MustGetNull()
	}
	if !s.ContentMediaURL.IsUnset() {
		t.ContentMediaURL = s.ContentMediaURL.MustGetNull()
	}
	if !s.ContentMetadata.IsUnset() {
		t.ContentMetadata = s.ContentMetadata.MustGetNull()
	}
	if !s.ReplyToID.IsUnset() {
		t.ReplyToID = s.ReplyToID.MustGetNull()
	}
	if s.IsEdited.IsValue() {
		t.IsEdited = s.IsEdited.MustGet()
	}
	if !s.EditedAt.IsUnset() {
		t.EditedAt = s.EditedAt.MustGetNull()
	}
	if s.DeletedForAll.IsValue() {
		t.DeletedForAll = s.DeletedForAll.MustGet()
	}
	if s.CreatedAt.IsValue() {
		t.CreatedAt = s.CreatedAt.MustGet()
	}
}

func (s *MessageSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Messages.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 13)
		if s.ID.IsValue() {
			vals[0] = psql.Arg(s.ID.MustGet())
		} else {
			vals[0] = psql.Raw("DEFAULT")
		}

		if s.ConversationID.IsValue() {
			vals[1] = psql.Arg(s.ConversationID.MustGet())
		} else {
			vals[1] = psql.Raw("DEFAULT")
		}

		if s.SenderID.IsValue() {
			vals[2] = psql.Arg(s.SenderID.MustGet())
		} else {
			vals[2] = psql.Raw("DEFAULT")
		}

		if s.ContentType.IsValue() {
			vals[3] = psql.Arg(s.ContentType.MustGet())
		} else {
			vals[3] = psql.Raw("DEFAULT")
		}

		if !s.ContentText.IsUnset() {
			vals[4] = psql.Arg(s.ContentText.MustGetNull())
		} else {
			vals[4] = psql.Raw("DEFAULT")
		}

		if !s.ContentMediaID.IsUnset() {
			vals[5] = psql.Arg(s.ContentMediaID.MustGetNull())
		} else {
			vals[5] = psql.Raw("DEFAULT")
		}

		if !s.ContentMediaURL.IsUnset() {
			vals[6] = psql.Arg(s.ContentMediaURL.MustGetNull())
		} else {
			vals[6] = psql.Raw("DEFAULT")
		}

		if !s.ContentMetadata.IsUnset() {
			vals[7] = psql.Arg(s.ContentMetadata.MustGetNull())
		} else {
			vals[7] = psql.Raw("DEFAULT")
		}

		if !s.ReplyToID.IsUnset() {
			vals[8] = psql.Arg(s.ReplyToID.MustGetNull())
		} else {
			vals[8] = psql.Raw("DEFAULT")
		}

		if s.IsEdited.IsValue() {
			vals[9] = psql.Arg(s.IsEdited.MustGet())
		} else {
			vals[9] = psql.Raw("DEFAULT")
		}

		if !s.EditedAt.IsUnset() {
			vals[10] = psql.Arg(s.EditedAt.MustGetNull())
		} else {
			vals[10] = psql.Raw("DEFAULT")
		}

		if s.DeletedForAll.IsValue() {
			vals[11] = psql.Arg(s.DeletedForAll.MustGet())
		} else {
			vals[11] = psql.Raw("DEFAULT")
		}

		if s.CreatedAt.IsValue() {
			vals[12] = psql.Arg(s.CreatedAt.MustGet())
		} else {
			vals[12] = psql.Raw("DEFAULT")
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s MessageSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s MessageSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 13)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "id")...),
			psql.Arg(s.ID),
		}})
	}

	if s.ConversationID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "conversation_id")...),
			psql.Arg(s.ConversationID),
		}})
	}

	if s.SenderID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "sender_id")...),
			psql.Arg(s.SenderID),
		}})
	}

	if s.ContentType.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content_type")...),
			psql.Arg(s.ContentType),
		}})
	}

	if !s.ContentText.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content_text")...),
			psql.Arg(s.ContentText),
		}})
	}

	if !s.ContentMediaID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content_media_id")...),
			psql.Arg(s.ContentMediaID),
		}})
	}

	if !s.ContentMediaURL.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content_media_url")...),
			psql.Arg(s.ContentMediaURL),
		}})
	}

	if !s.ContentMetadata.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "content_metadata")...),
			psql.Arg(s.ContentMetadata),
		}})
	}

	if !s.ReplyToID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "reply_to_id")...),
			psql.Arg(s.ReplyToID),
		}})
	}

	if s.IsEdited.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "is_edited")...),
			psql.Arg(s.IsEdited),
		}})
	}

	if !s.EditedAt.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "edited_at")...),
			psql.Arg(s.EditedAt),
		}})
	}

	if s.DeletedForAll.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "deleted_for_all")...),
			psql.Arg(s.DeletedForAll),
		}})
	}

	if s.CreatedAt.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "created_at")...),
			psql.Arg(s.CreatedAt),
		}})
	}

	return exprs
}

// FindMessage retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindMessage(ctx context.Context, exec bob.Executor, IDPK uuid.UUID, cols ...string) (*Message, error) {
	if len(cols) == 0 {
		return Messages.Query(
			sm.Where(Messages.Columns.ID.EQ(psql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return Messages.Query(
		sm.Where(Messages.Columns.ID.EQ(psql.Arg(IDPK))),
		sm.Columns(Messages.Columns.Only(cols...)),
	).One(ctx, exec)
}

// MessageExists checks the presence of a single record by primary key
func MessageExists(ctx context.Context, exec bob.Executor, IDPK uuid.UUID) (bool, error) {
	return Messages.Query(
		sm.Where(Messages.Columns.ID.EQ(psql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Message is retrieved from the database
func (o *Message) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Messages.AfterSelectHooks.RunHooks(ctx, exec, MessageSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Messages.AfterInsertHooks.RunHooks(ctx, exec, MessageSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Messages.AfterUpdateHooks.RunHooks(ctx, exec, MessageSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Messages.AfterDeleteHooks.RunHooks(ctx, exec, MessageSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Message
func (o *Message) primaryKeyVals() bob.Expression {
	return psql.Arg(o.ID)
}

func (o *Message) pkEQ() dialect.Expression {
	return psql.Quote("messages", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Message
func (o *Message) Update(ctx context.Context, exec bob.Executor, s *MessageSetter) error {
	v, err := Messages.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single Message record with an executor
func (o *Message) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Messages.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Message using the executor
func (o *Message) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Messages.Query(
		sm.Where(Messages.Columns.ID.EQ(psql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after MessageSlice is retrieved from the database
func (o MessageSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Messages.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Messages.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Messages.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Messages.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o MessageSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("messages", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o MessageSlice) copyMatchingRows(from ...*Message) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o MessageSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Messages.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Message:
				o.copyMatchingRows(retrieved)
			case []*Message:
				o.copyMatchingRows(retrieved...)
			case MessageSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Message or a slice of Message
				// then run the AfterUpdateHooks on the slice
				_, err = Messages.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o MessageSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Messages.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Message:
				o.copyMatchingRows(retrieved)
			case []*Message:
				o.copyMatchingRows(retrieved...)
			case MessageSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Message or a slice of Message
				// then run the AfterDeleteHooks on the slice
				_, err = Messages.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o MessageSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals MessageSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Messages.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o MessageSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Messages.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o MessageSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Messages.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// MessageDeletions starts a query for related objects on message_deletions
func (o *Message) MessageDeletions(mods ...bob.Mod[*dialect.SelectQuery]) MessageDeletionsQuery {
	return MessageDeletions.Query(append(mods,
		sm.Where(MessageDeletions.Columns.MessageID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MessageSlice) MessageDeletions(mods ...bob.Mod[*dialect.SelectQuery]) MessageDeletionsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return MessageDeletions.Query(append(mods,
		sm.Where(psql.Group(MessageDeletions.Columns.MessageID).OP("IN", PKArgExpr)),
	)...)
}

// MessageReactions starts a query for related objects on message_reactions
func (o *Message) MessageReactions(mods ...bob.Mod[*dialect.SelectQuery]) MessageReactionsQuery {
	return MessageReactions.Query(append(mods,
		sm.Where(MessageReactions.Columns.MessageID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MessageSlice) MessageReactions(mods ...bob.Mod[*dialect.SelectQuery]) MessageReactionsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return MessageReactions.Query(append(mods,
		sm.Where(psql.Group(MessageReactions.Columns.MessageID).OP("IN", PKArgExpr)),
	)...)
}

// MessageReceipts starts a query for related objects on message_receipts
func (o *Message) MessageReceipts(mods ...bob.Mod[*dialect.SelectQuery]) MessageReceiptsQuery {
	return MessageReceipts.Query(append(mods,
		sm.Where(MessageReceipts.Columns.MessageID.EQ(psql.Arg(o.ID))),
	)...)
}

func (os MessageSlice) MessageReceipts(mods ...bob.Mod[*dialect.SelectQuery]) MessageReceiptsQuery {
	pkID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkID = append(pkID, o.ID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkID), "uuid[]")),
	))

	return MessageReceipts.Query(append(mods,
		sm.Where(psql.Group(MessageReceipts.Columns.MessageID).OP("IN", PKArgExpr)),
	)...)
}

// Conversation starts a query for related objects on conversations
func (o *Message) Conversation(mods ...bob.Mod[*dialect.SelectQuery]) ConversationsQuery {
	return Conversations.Query(append(mods,
		sm.Where(Conversations.Columns.ID.EQ(psql.Arg(o.ConversationID))),
	)...)
}

func (os MessageSlice) Conversation(mods ...bob.Mod[*dialect.SelectQuery]) ConversationsQuery {
	pkConversationID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkConversationID = append(pkConversationID, o.ConversationID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkConversationID), "uuid[]")),
	))

	return Conversations.Query(append(mods,
		sm.Where(psql.Group(Conversations.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// SenderUser starts a query for related objects on users
func (o *Message) SenderUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	return Users.Query(append(mods,
		sm.Where(Users.Columns.ID.EQ(psql.Arg(o.SenderID))),
	)...)
}

func (os MessageSlice) SenderUser(mods ...bob.Mod[*dialect.SelectQuery]) UsersQuery {
	pkSenderID := make(pgtypes.Array[uuid.UUID], 0, len(os))
	for _, o := range os {
		if o == nil {
			continue
		}
		pkSenderID = append(pkSenderID, o.SenderID)
	}
	PKArgExpr := psql.Select(sm.Columns(
		psql.F("unnest", psql.Cast(psql.Arg(pkSenderID), "uuid[]")),
	))

	return Users.Query(append(mods,
		sm.Where(psql.Group(Users.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func insertMessageMessageDeletions0(ctx context.Context, exec bob.Executor, messageDeletions1 []*MessageDeletionSetter, message0 *Message) (MessageDeletionSlice, error) {
	for i := range messageDeletions1 {
		messageDeletions1[i].MessageID = omit.From(message0.ID)
	}

	ret, err := MessageDeletions.Insert(bob.ToMods(messageDeletions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMessageMessageDeletions0: %w", err)
	}

	return ret, nil
}

func attachMessageMessageDeletions0(ctx context.Context, exec bob.Executor, count int, messageDeletions1 MessageDeletionSlice, message0 *Message) (MessageDeletionSlice, error) {
	setter := &MessageDeletionSetter{
		MessageID: omit.From(message0.ID),
	}

	err := messageDeletions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMessageMessageDeletions0: %w", err)
	}

	return messageDeletions1, nil
}

func (message0 *Message) InsertMessageDeletions(ctx context.Context, exec bob.Executor, related ...*MessageDeletionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	messageDeletions1, err := insertMessageMessageDeletions0(ctx, exec, related, message0)
	if err != nil {
		return err
	}

	message0.R.MessageDeletions = append(message0.R.MessageDeletions, messageDeletions1...)

	for _, rel := range messageDeletions1 {
		rel.R.Message = message0
	}
	return nil
}

func (message0 *Message) AttachMessageDeletions(ctx context.Context, exec bob.Executor, related ...*MessageDeletion) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	messageDeletions1 := MessageDeletionSlice(related)

	_, err = attachMessageMessageDeletions0(ctx, exec, len(related), messageDeletions1, message0)
	if err != nil {
		return err
	}

	message0.R.MessageDeletions = append(message0.R.MessageDeletions, messageDeletions1...)

	for _, rel := range related {
		rel.R.Message = message0
	}

	return nil
}

func insertMessageMessageReactions0(ctx context.Context, exec bob.Executor, messageReactions1 []*MessageReactionSetter, message0 *Message) (MessageReactionSlice, error) {
	for i := range messageReactions1 {
		messageReactions1[i].MessageID = omit.From(message0.ID)
	}

	ret, err := MessageReactions.Insert(bob.ToMods(messageReactions1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMessageMessageReactions0: %w", err)
	}

	return ret, nil
}

func attachMessageMessageReactions0(ctx context.Context, exec bob.Executor, count int, messageReactions1 MessageReactionSlice, message0 *Message) (MessageReactionSlice, error) {
	setter := &MessageReactionSetter{
		MessageID: omit.From(message0.ID),
	}

	err := messageReactions1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMessageMessageReactions0: %w", err)
	}

	return messageReactions1, nil
}

func (message0 *Message) InsertMessageReactions(ctx context.Context, exec bob.Executor, related ...*MessageReactionSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	messageReactions1, err := insertMessageMessageReactions0(ctx, exec, related, message0)
	if err != nil {
		return err
	}

	message0.R.MessageReactions = append(message0.R.MessageReactions, messageReactions1...)

	for _, rel := range messageReactions1 {
		rel.R.Message = message0
	}
	return nil
}

func (message0 *Message) AttachMessageReactions(ctx context.Context, exec bob.Executor, related ...*MessageReaction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	messageReactions1 := MessageReactionSlice(related)

	_, err = attachMessageMessageReactions0(ctx, exec, len(related), messageReactions1, message0)
	if err != nil {
		return err
	}

	message0.R.MessageReactions = append(message0.R.MessageReactions, messageReactions1...)

	for _, rel := range related {
		rel.R.Message = message0
	}

	return nil
}

func insertMessageMessageReceipts0(ctx context.Context, exec bob.Executor, messageReceipts1 []*MessageReceiptSetter, message0 *Message) (MessageReceiptSlice, error) {
	for i := range messageReceipts1 {
		messageReceipts1[i].MessageID = omit.From(message0.ID)
	}

	ret, err := MessageReceipts.Insert(bob.ToMods(messageReceipts1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertMessageMessageReceipts0: %w", err)
	}

	return ret, nil
}

func attachMessageMessageReceipts0(ctx context.Context, exec bob.Executor, count int, messageReceipts1 MessageReceiptSlice, message0 *Message) (MessageReceiptSlice, error) {
	setter := &MessageReceiptSetter{
		MessageID: omit.From(message0.ID),
	}

	err := messageReceipts1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachMessageMessageReceipts0: %w", err)
	}

	return messageReceipts1, nil
}

func (message0 *Message) InsertMessageReceipts(ctx context.Context, exec bob.Executor, related ...*MessageReceiptSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	messageReceipts1, err := insertMessageMessageReceipts0(ctx, exec, related, message0)
	if err != nil {
		return err
	}

	message0.R.MessageReceipts = append(message0.R.MessageReceipts, messageReceipts1...)

	for _, rel := range messageReceipts1 {
		rel.R.Message = message0
	}
	return nil
}

func (message0 *Message) AttachMessageReceipts(ctx context.Context, exec bob.Executor, related ...*MessageReceipt) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	messageReceipts1 := MessageReceiptSlice(related)

	_, err = attachMessageMessageReceipts0(ctx, exec, len(related), messageReceipts1, message0)
	if err != nil {
		return err
	}

	message0.R.MessageReceipts = append(message0.R.MessageReceipts, messageReceipts1...)

	for _, rel := range related {
		rel.R.Message = message0
	}

	return nil
}

func attachMessageConversation0(ctx context.Context, exec bob.Executor, count int, message0 *Message, conversation1 *Conversation) (*Message, error) {
	setter := &MessageSetter{
		ConversationID: omit.From(conversation1.ID),
	}

	err := message0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachMessageConversation0: %w", err)
	}

	return message0, nil
}

func (message0 *Message) InsertConversation(ctx context.Context, exec bob.Executor, related *ConversationSetter) error {
	var err error

	conversation1, err := Conversations.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMessageConversation0(ctx, exec, 1, message0, conversation1)
	if err != nil {
		return err
	}

	message0.R.Conversation = conversation1

	conversation1.R.Messages = append(conversation1.R.Messages, message0)

	return nil
}

func (message0 *Message) AttachConversation(ctx context.Context, exec bob.Executor, conversation1 *Conversation) error {
	var err error

	_, err = attachMessageConversation0(ctx, exec, 1, message0, conversation1)
	if err != nil {
		return err
	}

	message0.R.Conversation = conversation1

	conversation1.R.Messages = append(conversation1.R.Messages, message0)

	return nil
}

func attachMessageSenderUser0(ctx context.Context, exec bob.Executor, count int, message0 *Message, user1 *User) (*Message, error) {
	setter := &MessageSetter{
		SenderID: omit.From(user1.ID),
	}

	err := message0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachMessageSenderUser0: %w", err)
	}

	return message0, nil
}

func (message0 *Message) InsertSenderUser(ctx context.Context, exec bob.Executor, related *UserSetter) error {
	var err error

	user1, err := Users.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachMessageSenderUser0(ctx, exec, 1, message0, user1)
	if err != nil {
		return err
	}

	message0.R.SenderUser = user1

	user1.R.SenderMessages = append(user1.R.SenderMessages, message0)

	return nil
}

func (message0 *Message) AttachSenderUser(ctx context.Context, exec bob.Executor, user1 *User) error {
	var err error

	_, err = attachMessageSenderUser0(ctx, exec, 1, message0, user1)
	if err != nil {
		return err
	}

	message0.R.SenderUser = user1

	user1.R.SenderMessages = append(user1.R.SenderMessages, message0)

	return nil
}

type messageWhere[Q psql.Filterable] struct {
	ID              psql.WhereMod[Q, uuid.UUID]
	ConversationID  psql.WhereMod[Q, uuid.UUID]
	SenderID        psql.WhereMod[Q, uuid.UUID]
	ContentType     psql.WhereMod[Q, string]
	ContentText     psql.WhereNullMod[Q, string]
	ContentMediaID  psql.WhereNullMod[Q, uuid.UUID]
	ContentMediaURL psql.WhereNullMod[Q, string]
	ContentMetadata psql.WhereNullMod[Q, types.JSON[json.RawMessage]]
	ReplyToID       psql.WhereNullMod[Q, uuid.UUID]
	IsEdited        psql.WhereMod[Q, bool]
	EditedAt        psql.WhereNullMod[Q, time.Time]
	DeletedForAll   psql.WhereMod[Q, bool]
	CreatedAt       psql.WhereMod[Q, time.Time]
}

func (messageWhere[Q]) AliasedAs(alias string) messageWhere[Q] {
	return buildMessageWhere[Q](buildMessageColumns(alias))
}

func buildMessageWhere[Q psql.Filterable](cols messageColumns) messageWhere[Q] {
	return messageWhere[Q]{
		ID:              psql.Where[Q, uuid.UUID](cols.ID),
		ConversationID:  psql.Where[Q, uuid.UUID](cols.ConversationID),
		SenderID:        psql.Where[Q, uuid.UUID](cols.SenderID),
		ContentType:     psql.Where[Q, string](cols.ContentType),
		ContentText:     psql.WhereNull[Q, string](cols.ContentText),
		ContentMediaID:  psql.WhereNull[Q, uuid.UUID](cols.ContentMediaID),
		ContentMediaURL: psql.WhereNull[Q, string](cols.ContentMediaURL),
		ContentMetadata: psql.WhereNull[Q, types.JSON[json.RawMessage]](cols.ContentMetadata),
		ReplyToID:       psql.WhereNull[Q, uuid.UUID](cols.ReplyToID),
		IsEdited:        psql.Where[Q, bool](cols.IsEdited),
		EditedAt:        psql.WhereNull[Q, time.Time](cols.EditedAt),
		DeletedForAll:   psql.Where[Q, bool](cols.DeletedForAll),
		CreatedAt:       psql.Where[Q, time.Time](cols.CreatedAt),
	}
}

func (o *Message) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "MessageDeletions":
		rels, ok := retrieved.(MessageDeletionSlice)
		if !ok {
			return fmt.Errorf("message cannot load %T as %q", retrieved, name)
		}

		o.R.MessageDeletions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Message = o
			}
		}
		return nil
	case "MessageReactions":
		rels, ok := retrieved.(MessageReactionSlice)
		if !ok {
			return fmt.Errorf("message cannot load %T as %q", retrieved, name)
		}

		o.R.MessageReactions = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Message = o
			}
		}
		return nil
	case "MessageReceipts":
		rels, ok := retrieved.(MessageReceiptSlice)
		if !ok {
			return fmt.Errorf("message cannot load %T as %q", retrieved, name)
		}

		o.R.MessageReceipts = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Message = o
			}
		}
		return nil
	case "Conversation":
		rel, ok := retrieved.(*Conversation)
		if !ok {
			return fmt.Errorf("message cannot load %T as %q", retrieved, name)
		}

		o.R.Conversation = rel

		if rel != nil {
			rel.R.Messages = MessageSlice{o}
		}
		return nil
	case "SenderUser":
		rel, ok := retrieved.(*User)
		if !ok {
			return fmt.Errorf("message cannot load %T as %q", retrieved, name)
		}

		o.R.SenderUser = rel

		if rel != nil {
			rel.R.SenderMessages = MessageSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("message has no relationship %q", name)
	}
}

type messagePreloader struct {
	Conversation func(...psql.PreloadOption) psql.Preloader
	SenderUser   func(...psql.PreloadOption) psql.Preloader
}

func buildMessagePreloader() messagePreloader {
	return messagePreloader{
		Conversation: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*Conversation, ConversationSlice](psql.PreloadRel{
				Name: "Conversation",
				Sides: []psql.PreloadSide{
					{
						From:        Messages,
						To:          Conversations,
						FromColumns: []string{"conversation_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Conversations.Columns.Names(), opts...)
		},
		SenderUser: func(opts ...psql.PreloadOption) psql.Preloader {
			return psql.Preload[*User, UserSlice](psql.PreloadRel{
				Name: "SenderUser",
				Sides: []psql.PreloadSide{
					{
						From:        Messages,
						To:          Users,
						FromColumns: []string{"sender_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Users.Columns.Names(), opts...)
		},
	}
}

type messageThenLoader[Q orm.Loadable] struct {
	MessageDeletions func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	MessageReactions func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	MessageReceipts  func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Conversation     func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	SenderUser       func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildMessageThenLoader[Q orm.Loadable]() messageThenLoader[Q] {
	type MessageDeletionsLoadInterface interface {
		LoadMessageDeletions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MessageReactionsLoadInterface interface {
		LoadMessageReactions(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type MessageReceiptsLoadInterface interface {
		LoadMessageReceipts(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type ConversationLoadInterface interface {
		LoadConversation(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type SenderUserLoadInterface interface {
		LoadSenderUser(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return messageThenLoader[Q]{
		MessageDeletions: thenLoadBuilder[Q](
			"MessageDeletions",
			func(ctx context.Context, exec bob.Executor, retrieved MessageDeletionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMessageDeletions(ctx, exec, mods...)
			},
		),
		MessageReactions: thenLoadBuilder[Q](
			"MessageReactions",
			func(ctx context.Context, exec bob.Executor, retrieved MessageReactionsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMessageReactions(ctx, exec, mods...)
			},
		),
		MessageReceipts: thenLoadBuilder[Q](
			"MessageReceipts",
			func(ctx context.Context, exec bob.Executor, retrieved MessageReceiptsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadMessageReceipts(ctx, exec, mods...)
			},
		),
		Conversation: thenLoadBuilder[Q](
			"Conversation",
			func(ctx context.Context, exec bob.Executor, retrieved ConversationLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadConversation(ctx, exec, mods...)
			},
		),
		SenderUser: thenLoadBuilder[Q](
			"SenderUser",
			func(ctx context.Context, exec bob.Executor, retrieved SenderUserLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadSenderUser(ctx, exec, mods...)
			},
		),
	}
}

// LoadMessageDeletions loads the message's MessageDeletions into the .R struct
func (o *Message) LoadMessageDeletions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.MessageDeletions = nil

	related, err := o.MessageDeletions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Message = o
	}

	o.R.MessageDeletions = related
	return nil
}

// LoadMessageDeletions loads the message's MessageDeletions into the .R struct
func (os MessageSlice) LoadMessageDeletions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	messageDeletions, err := os.MessageDeletions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.MessageDeletions = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range messageDeletions {

			if !(o.ID == rel.MessageID) {
				continue
			}

			rel.R.Message = o

			o.R.MessageDeletions = append(o.R.MessageDeletions, rel)
		}
	}

	return nil
}

// LoadMessageReactions loads the message's MessageReactions into the .R struct
func (o *Message) LoadMessageReactions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.MessageReactions = nil

	related, err := o.MessageReactions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Message = o
	}

	o.R.MessageReactions = related
	return nil
}

// LoadMessageReactions loads the message's MessageReactions into the .R struct
func (os MessageSlice) LoadMessageReactions(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	messageReactions, err := os.MessageReactions(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.MessageReactions = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range messageReactions {

			if !(o.ID == rel.MessageID) {
				continue
			}

			rel.R.Message = o

			o.R.MessageReactions = append(o.R.MessageReactions, rel)
		}
	}

	return nil
}

// LoadMessageReceipts loads the message's MessageReceipts into the .R struct
func (o *Message) LoadMessageReceipts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.MessageReceipts = nil

	related, err := o.MessageReceipts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Message = o
	}

	o.R.MessageReceipts = related
	return nil
}

// LoadMessageReceipts loads the message's MessageReceipts into the .R struct
func (os MessageSlice) LoadMessageReceipts(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	messageReceipts, err := os.MessageReceipts(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.MessageReceipts = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range messageReceipts {

			if !(o.ID == rel.MessageID) {
				continue
			}

			rel.R.Message = o

			o.R.MessageReceipts = append(o.R.MessageReceipts, rel)
		}
	}

	return nil
}

// LoadConversation loads the message's Conversation into the .R struct
func (o *Message) LoadConversation(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Conversation = nil

	related, err := o.Conversation(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Messages = MessageSlice{o}

	o.R.Conversation = related
	return nil
}

// LoadConversation loads the message's Conversation into the .R struct
func (os MessageSlice) LoadConversation(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	conversations, err := os.Conversation(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range conversations {

			if !(o.ConversationID == rel.ID) {
				continue
			}

			rel.R.Messages = append(rel.R.Messages, o)

			o.R.Conversation = rel
			break
		}
	}

	return nil
}

// LoadSenderUser loads the message's SenderUser into the .R struct
func (o *Message) LoadSenderUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.SenderUser = nil

	related, err := o.SenderUser(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.SenderMessages = MessageSlice{o}

	o.R.SenderUser = related
	return nil
}

// LoadSenderUser loads the message's SenderUser into the .R struct
func (os MessageSlice) LoadSenderUser(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	users, err := os.SenderUser(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range users {

			if !(o.SenderID == rel.ID) {
				continue
			}

			rel.R.SenderMessages = append(rel.R.SenderMessages, o)

			o.R.SenderUser = rel
			break
		}
	}

	return nil
}

type messageJoins[Q dialect.Joinable] struct {
	typ              string
	MessageDeletions modAs[Q, messageDeletionColumns]
	MessageReactions modAs[Q, messageReactionColumns]
	MessageReceipts  modAs[Q, messageReceiptColumns]
	Conversation     modAs[Q, conversationColumns]
	SenderUser       modAs[Q, userColumns]
}

func (j messageJoins[Q]) aliasedAs(alias string) messageJoins[Q] {
	return buildMessageJoins[Q](buildMessageColumns(alias), j.typ)
}

func buildMessageJoins[Q dialect.Joinable](cols messageColumns, typ string) messageJoins[Q] {
	return messageJoins[Q]{
		typ: typ,
		MessageDeletions: modAs[Q, messageDeletionColumns]{
			c: MessageDeletions.Columns,
			f: func(to messageDeletionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, MessageDeletions.Name().As(to.Alias())).On(
						to.MessageID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		MessageReactions: modAs[Q, messageReactionColumns]{
			c: MessageReactions.Columns,
			f: func(to messageReactionColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, MessageReactions.Name().As(to.Alias())).On(
						to.MessageID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		MessageReceipts: modAs[Q, messageReceiptColumns]{
			c: MessageReceipts.Columns,
			f: func(to messageReceiptColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, MessageReceipts.Name().As(to.Alias())).On(
						to.MessageID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Conversation: modAs[Q, conversationColumns]{
			c: Conversations.Columns,
			f: func(to conversationColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Conversations.Name().As(to.Alias())).On(
						to.ID.EQ(cols.ConversationID),
					))
				}

				return mods
			},
		},
		SenderUser: modAs[Q, userColumns]{
			c: Users.Columns,
			f: func(to userColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Users.Name().As(to.Alias())).On(
						to.ID.EQ(cols.SenderID),
					))
				}

				return mods
			},
		},
	}
}
